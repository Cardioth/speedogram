<!DOCTYPE html>
<html>
<title>Speed-o-Gram</title>
<style>
  body {
    font-family: Arial, sans-serif;
  }
  #appHeader {
    width: 900px;
    margin: 14px auto 4px;
    text-align: center;
    color: #0088FF;
  }
  #appTitle {
    margin: 0;
    font-size: 40px;
    line-height: 1;
    letter-spacing: 0.4px;
  }
  #appVersion {
    margin-top: 4px;
    font-size: 12px;
  }
  #arena {
    width: 900px;
    margin: 10px auto 0;
    display: flex;
    gap: 20px;
    align-items: flex-start;
    justify-content: center;
  }
  #speedogram {
    display: block;
  }
  .hidden {
    display: none !important;
  }
  #controls {
    width: 900px;
    margin: 18px auto 8px;
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: center;
    color: #0088FF;
  }
  #playerName {
    border: 1px solid #8cc6ff;
    border-radius: 4px;
    padding: 6px;
    min-width: 180px;
  }
  #startButton {
    border: 1px solid #8cc6ff;
    background: #f7fbff;
    border-radius: 4px;
    color: #0088FF;
    padding: 6px 12px;
    cursor: pointer;
  }
  #startButton:disabled {
    cursor: not-allowed;
    opacity: 0.65;
  }
  #nameStatus,
  #matchStatus,
  #multiplayerPlayers {
    font-size: 13px;
    line-height: 1.4;
  }
  #multiplayerPanel {
    width: 400px;
    margin: 12px auto 0;
    font-family: Arial, sans-serif;
    color: #0088FF;
  }
  #multiplayerPanel h3 {
    margin: 0 0 6px;
    font-size: 16px;
  }
  #multiplayerPlayers {
    font-size: 13px;
    line-height: 1.4;
  }
</style>
<body>
  <div id="appHeader">
    <h1 id="appTitle">Speed-o-Gram</h1>
    <div id="appVersion"></div>
  </div>
  <div id="controls" class="matchmakingUI">
    <input id="playerName" maxlength="24" placeholder="Player name" />
    <button id="startButton">Start</button>
  </div>
  <div id="matchStatus" class="matchmakingUI" style="text-align:center;color:#0088FF;font-size:13px;">Enter your name and click Start.</div>
    <div id="arena">
    <canvas id="speedogram" width="900" height="440">Hello</canvas>
  </div>
  <div id="multiplayerPanel">
    <h3>Live Players</h3>
    <div id="multiplayerPlayers">Waiting for players…</div>
  </div>
</body>

<script src="/socket.io/socket.io.js"></script>
<script>
var versionNumber = "V0.1"
var canvas = document.getElementById('speedogram');
var canvasSize = canvas.width;
var height = canvas.height;
var totalLives = 3;
var lives = totalLives;
var gridSize = 3;
var level = 0;
var gridSizeIntervals = [3,3,3,4,4,4,5,5,5,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,9,9,10,10];
var cellSize = 22;
var gridBoundaryMargin = 76;
var overallGridSize = gridSize*cellSize;
var gridOffSetX = 120;
var gridOffSetY = 120;
var mouseState = "up";
var mouseButton;
var timer;
var timerState = "stopped";
var timeLimitInit = 6000;
var timeLimit = timeLimitInit;
var timeIncrement = 700;
var score = 0;

var socket = typeof io !== "undefined" ? io() : null;
var myPlayerName = "Player" + Math.floor(Math.random()*1000);
var latestRoster = [];
var startButton = document.getElementById("startButton");
var playerNameInput = document.getElementById("playerName");
var matchStatusEl = document.getElementById("matchStatus");
var opponentState = null;
var appVersionEl = document.getElementById("appVersion");
var sharedTimeRemaining = "--";
var opponentGridOffSetX = 560;
var myDisplayName = "You";
var opponentDisplayName = "Opponent";
var pendingPredictions = [];
var MAX_PENDING_PREDICTIONS = 64;
var HEART_ICON_WIDTH = 24;
var HEART_SPACING = 25;
var lastDraggedCell = null;

function updateMultiplayerPanel(players){
  var panel = document.getElementById("multiplayerPlayers");
  if(!panel){
    return;
  }
  latestRoster = players || [];
  if(!latestRoster.length){
    panel.textContent = "Waiting for players…";
    return;
  }
  panel.innerHTML = latestRoster
    .map(function(player){
      return player.name + " — score " + player.score + ", lvl " + player.level + ", lives " + player.lives + " (" + player.gameMode + ")";
    })
    .join("<br>");
}

function sendPlayerUpdate(){
  if(!socket){
    return;
  }
  socket.emit("player:set-name", { name: myPlayerName });
}

function setMatchStatus(text){
  if(matchStatusEl){
    matchStatusEl.textContent = text;
  }
}


function setMatchmakingVisible(visible){
  var elements = document.querySelectorAll(".matchmakingUI");
  for(var i = 0; i < elements.length; i++){
    elements[i].classList.toggle("hidden", !visible);
  }
}

function updateSharedClock(currentTimer, limit){
  if(!Number.isFinite(currentTimer) || !Number.isFinite(limit) || limit <= 0){
    return;
  }
  sharedTimeRemaining = Math.max(0, Math.ceil((limit - currentTimer) / 100));
}


function drawOpponentBoard(){
  if(!opponentState){
    ctx.font = "16px Arial";
    ctx.fillStyle = "#0088FF";
    ctx.fillText("Waiting for opponent board...", opponentGridOffSetX + 40, 200);
    return;
  }

  var opGridSize = opponentState.gridSize || 3;
  var opOverallGridSize = opGridSize * cellSize;
  var opGridOffSetY = 120;

  ctx.globalAlpha = 0.1;
  ctx.fillStyle = "#0088FF";
  ctx.roundRect(opponentGridOffSetX-gridBoundaryMargin,opGridOffSetY-gridBoundaryMargin,opOverallGridSize+(gridBoundaryMargin+15),opOverallGridSize+(gridBoundaryMargin+15), 5,true,false);
  ctx.globalAlpha = 1;
  ctx.strokeStyle = "#0088FF";
  ctx.lineWidth = .75;
  ctx.roundRect(opponentGridOffSetX-gridBoundaryMargin,opGridOffSetY-gridBoundaryMargin,opOverallGridSize+(gridBoundaryMargin+15),opOverallGridSize+(gridBoundaryMargin+15), 5,false,true);

  var X = opponentState.Xcounters || [];
  var Y = opponentState.Ycounters || [];
  for (var counts in X){
    for(var seg in X[counts]){
      ctx.font = "11px Arial";
      ctx.fillStyle = "#0088FF";
      ctx.fillText(X[counts][X[counts].length-seg-1], opponentGridOffSetX+(cellSize/4)+(counts*cellSize), opGridOffSetY-10-(seg*15));
    }
  }
  for (var rowCounts in Y){
    for(var rowSeg in Y[rowCounts]){
      ctx.font = "11px Arial";
      ctx.fillStyle = "#0088FF";
      ctx.fillText(Y[rowCounts][Y[rowCounts].length-rowSeg-1], opponentGridOffSetX-(rowSeg*15)-14, opGridOffSetY+6+(cellSize/4)+(rowCounts*cellSize));
    }
  }

  var guesses = opponentState.gridGuesses || [];
  for(var i = 0; i<opGridSize;i++){
    for(var j = 0; j<opGridSize;j++){
      ctx.lineWidth = 1;
      ctx.strokeStyle = "#0088FF";
      ctx.fillStyle = "#FFFFFF";
      ctx.roundRect(i*cellSize+opponentGridOffSetX,j*cellSize+opGridOffSetY,cellSize,cellSize, 3,true,true);
      if(guesses[i] && guesses[i][j] === 1){
        ctx.fillStyle = "#0088FF";
        ctx.roundRect(i*cellSize+opponentGridOffSetX,j*cellSize+opGridOffSetY,cellSize,cellSize, 3,true,false);
      }
    }
  }

  var opLives = opponentState.lives || 0;
  for(var livesCount = 0;livesCount<opLives;livesCount++){
    renderOpponentHeart((livesCount*25)+opponentGridOffSetX+10-(opLives*12.5),opGridOffSetY+opOverallGridSize+25);
  }

  var opScore = opponentState.score || 0;
  for(var star = 0; star < opScore; star++){
    renderStar(opponentGridOffSetX-42,60+(star%5*20));
  }
}

function initMultiplayer(){
  if(!socket){
    updateMultiplayerPanel([]);
    return;
  }
  socket.on("players:update", function(players){
    updateMultiplayerPanel(players);
  });

  socket.on("match:ready", function(payload){
    pendingPredictions = [];
    gameMode = "waiting";
    setMatchStatus("Match found! Starting vs " + payload.opponentName + "...");
  });

  socket.on("match:update", function(payload){
    applyServerState(payload.player);
    opponentState = payload.opponent;
    myDisplayName = (payload.player && payload.player.name) ? payload.player.name : myPlayerName;
    opponentDisplayName = (payload.opponent && payload.opponent.name) ? payload.opponent.name : "Opponent";
    drawOpponentBoard();
    if(gameMode === "waiting" || gameMode === "menu"){
      gameMode = "play";
      setMatchStatus("Playing against " + (payload.opponent && payload.opponent.name ? payload.opponent.name : "opponent"));
      startButton.disabled = true;
      startButton.textContent = "In Match";
      setMatchmakingVisible(false);
    }
    if(payload.player && payload.player.gameMode === "gameOver"){
      gameMode = "gameOver";
      if(payload.playerRematchRequested){
        startButton.disabled = true;
        startButton.textContent = "Waiting...";
        if(payload.opponentRematchRequested){
          setMatchStatus("Restarting match...");
        } else {
          setMatchStatus("Rematch requested. Waiting for opponent...");
        }
      } else {
        setMatchStatus("Game over. Click Start to request a rematch.");
        startButton.disabled = false;
        startButton.textContent = "Start";
      }
      setMatchmakingVisible(true);
    }
  });

  socket.on("match:ended", function(payload){
    gameMode = "menu";
    opponentState = null;
    opponentDisplayName = "Opponent";
    myDisplayName = myPlayerName;
    drawOpponentBoard();
    startButton.disabled = false;
    startButton.textContent = "Start";
    setMatchmakingVisible(true);
    sharedTimeRemaining = "--";
    pendingPredictions = [];
    setMatchStatus(payload.reason || "Match ended.");
  });
}

var grid = [];
var gridGuesses = [];

var can = document.getElementById("speedogram");

can.addEventListener("touchstart", mouseDown, false);
can.addEventListener("touchend", mouseUp, false);

can.addEventListener("mousemove", mouseMove, false);
can.addEventListener("mouseup", mouseUp, false);
can.addEventListener("mousedown", mouseDown, false);
can.addEventListener("click", click, false);

var ctx = can.getContext("2d");
var mouseX;
var mouseY;

function init(){
  gameMode = "menu";
  if(appVersionEl){
    appVersionEl.textContent = versionNumber;
  }
  myDisplayName = myPlayerName;
  drawOpponentBoard();
  setMatchmakingVisible(true);
  enterFrame();
}

function renderBoardHeaders(){
  var myBoardCenterX = gridOffSetX + (overallGridSize/2);
  var opponentGridSize = (opponentState && opponentState.gridSize) ? opponentState.gridSize : gridSize;
  var opponentBoardCenterX = opponentGridOffSetX + ((opponentGridSize * cellSize)/2);

  ctx.font = "20px Arial";
  ctx.fillStyle = "#0088FF";

  var myName = myDisplayName || "You";
  var opponentName = opponentDisplayName || "Opponent";

  ctx.fillText(myName, myBoardCenterX - (ctx.measureText(myName).width / 2), 34);
  ctx.fillText(opponentName, opponentBoardCenterX - (ctx.measureText(opponentName).width / 2), 34);
}

function enterFrame(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  renderBoardHeaders();

  renderStopwatch(840,96);
  renderStopwatchHand(840,96,timer || 0);
  ctx.font = "14px Arial";
  ctx.fillStyle = "#0088FF";
  ctx.fillText("Time: " + sharedTimeRemaining, 790, 142);

  if(gameMode == "play" || gameMode == "gameOver"){
    renderBackdrop();
    renderCells();
    renderClueText();
    renderHealth();
    renderScore();
    drawOpponentBoard();
  }
  if(gameMode == "play"){
    renderMouseOver();
  }
  if(gameMode == "gameOver"){
    renderGameOver();
  }
  window.requestAnimationFrame(enterFrame);
}
function renderGameOver(){
  var boardCenterX = gridOffSetX + (overallGridSize/2);
  var gameOverText = "Final Score: " + score;
  ctx.font = "16px Arial";
  ctx.fillStyle = "#0088FF";
  ctx.fillText(gameOverText, boardCenterX-(ctx.measureText(gameOverText).width/2), gridOffSetY-52);
}

function hitTest(object){
  //Search scene objects for name
  for(var objects in sceneObjects){
    if(sceneObjects[objects].name == object){
      var obj = sceneObjects[objects];
    }
  }
  if(mouseX > obj.x-obj.width/2 && mouseX < obj.x+obj.width/2 && mouseY > obj.y-obj.height/2 && mouseY < obj.y+obj.height/2){
    return true;
  } else {
    return false;
  }
}

function renderSceneObjects(){
  for(var object in sceneObjects){
    var obj = sceneObjects[object];
    if(obj.type == "Button"){
        renderButton(obj.x,obj.y,obj.width,obj.height,obj.text);
    }
  }
}
function clearSceneObjects(){
  sceneObjects = [];
}

function renderButton(x,y,width,height,text){
  ctx.translate(x,y);
  ctx.globalAlpha = 0.2;
  ctx.fillStyle = "#0088FF";
  ctx.roundRect(-width/2,-height/2,width,height,3,true,false);
  ctx.globalAlpha = 1;
  ctx.strokeStyle = "#0088FF";
  ctx.roundRect(-width/2,-height/2,width,height,3,false,true);
  ctx.font = "18px Arial";
  ctx.fillStyle = "#0088FF";
  ctx.fillText(text,-(ctx.measureText(text).width/2),6);
  ctx.translate(-x,-y);
}

function createObject(xC,yC,widthC,heightC,nameC,typeC,textC){
  sceneObjects.push({x:xC,y:yC,width:widthC,height:heightC,name:nameC,type:typeC,text:textC});
}

function renderStopwatchTimer(x,y,time){
  var timeSeconds = timeLimit/100-Math.floor(time/100);
  ctx.save();
  ctx.translate(x,y);
  ctx.font = "12px Arial";
  ctx.fillStyle = "#0088FF";
  ctx.fillText(timeSeconds,0,0);
  ctx.restore();
}

function renderStopwatchHand(x,y,time){
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate((Math.PI / 180) * time*360/timeLimit);
  ctx.fillStyle = "#0088FF"
  ctx.fillRect(-2,-19,4,19);
  ctx.restore();
}
function renderScore(){
  for(var i=0;i<score;i++){
    renderStar(138-overallGridSize/2,60+(i%5*20));
  }
}
function renderStar(x,y){
  let p = new Path2D('M 0.55 -7.9 Q 0.5 -8.1 0.3 -8.25 0.15 -8.35 -0.1 -8.35 -0.3 -8.35 -0.5 -8.25 -0.65 -8.1 -0.75 -7.9 L -2.55 -2.7 -8.05 -2.55 Q -8.3 -2.55 -8.45 -2.45 -8.6 -2.3 -8.7 -2.1 -8.75 -1.9 -8.7 -1.65 -8.6 -1.45 -8.45 -1.35 L -4.1 2 -5.65 7.25 Q -5.75 7.45 -5.65 7.7 -5.6 7.9 -5.45 8.05 -5.25 8.15 -5 8.15 -4.8 8.15 -4.6 8.05 L -0.1 4.9 4.45 8.05 Q 4.6 8.15 4.8 8.15 5.05 8.15 5.25 8.05 5.4 7.9 5.45 7.7 5.55 7.45 5.45 7.25 L 3.9 2 8.25 -1.35 Q 8.4 -1.45 8.5 -1.65 8.55 -1.9 8.5 -2.1 8.4 -2.3 8.25 -2.45 8.1 -2.55 7.9 -2.55 L 2.35 -2.7 0.55 -7.9 Z');
  ctx.translate(x,y);
  ctx.fillStyle = "#0088FF"
  ctx.fill(p);
  ctx.translate(-x,-y);
}
function renderStopwatch(x,y){
  let p = new Path2D('M 8.5 -38.9 Q 7.95 -39.45 7.2 -39.45 L -7.95 -39.45 Q -8.75 -39.45 -9.3 -38.9 -9.85 -38.35 -9.85 -37.6 L -9.85 -34.9 Q -9.85 -34.15 -9.3 -33.55 -8.75 -33.05 -7.95 -33.05 L 7.2 -33.05 Q 7.95 -33.05 8.5 -33.55 9.05 -34.15 9.05 -34.9 L 9.05 -37.6 Q 9.05 -38.35 8.5 -38.9 M 5.3 -36.8 L 5.3 -35.7 -6.1 -35.7 -6.1 -36.8 5.3 -36.8 M 24.45 -27.6 Q 23.9 -28.15 23.15 -28.15 22.35 -28.15 21.8 -27.55 21.3 -27 21.3 -26.25 21.3 -25.7 21.6 -25.25 L 17.4 -21.1 Q 13 -24.8 7.7 -26.35 L 7.7 -30.1 Q 7.7 -30.85 7.2 -31.4 6.6 -31.95 5.85 -31.95 L -6.9 -31.95 Q -7.65 -31.95 -8.2 -31.4 -8.75 -30.85 -8.75 -30.1 L -8.75 -26.25 Q -13.7 -24.7 -17.85 -21.25 L -21.65 -25.05 Q -21.25 -25.6 -21.25 -26.25 -21.25 -27.05 -21.8 -27.55 -22.35 -28.15 -23.15 -28.15 -23.9 -28.15 -24.45 -27.55 L -25.65 -26.4 Q -25.7 -26.35 -25.7 -26.3 L -26.8 -25.3 Q -27.4 -24.8 -27.4 -24.05 -27.45 -23.25 -26.9 -22.7 -26.4 -22.1 -25.6 -22.05 -24.9 -22.05 -24.4 -22.45 L -20.6 -18.7 Q -28.1 -10.75 -28.1 0.3 -28.1 11.8 -19.95 19.9 -11.85 28.05 -0.35 28.05 11.15 28.05 19.3 19.9 27.4 11.8 27.4 0.3 27.4 -10.6 20.15 -18.5 L 24.25 -22.6 Q 24.8 -22.05 25.55 -22.05 26.35 -22.05 26.9 -22.65 27.4 -23.2 27.4 -23.95 27.4 -24.75 26.85 -25.3 L 24.45 -27.6 M 3.95 -28.2 L 3.95 -24.9 Q 3.95 -24.25 4.35 -23.7 4.75 -23.2 5.4 -23.05 11.75 -21.6 16.65 -16.7 23.65 -9.65 23.65 0.3 23.65 10.25 16.65 17.25 9.6 24.3 -0.35 24.3 -10.25 24.3 -17.3 17.25 -24.3 10.25 -24.3 0.3 -24.3 -9.65 -17.3 -16.7 -17 -17 -16.7 -17.25 L -16.65 -17.3 Q -16.65 -17.35 -16.6 -17.35 L -16.6 -17.4 Q -16.5 -17.45 -16.35 -17.55 -11.95 -21.6 -6.45 -23 -5.8 -23.15 -5.4 -23.65 -5 -24.15 -5 -24.8 L -5 -28.2 3.95 -28.2 M -1.65 21.1 Q -1.65 21.8 -1.15 22.3 -0.7 22.75 0 22.75 0.7 22.75 1.15 22.3 1.65 21.8 1.65 21.1 1.65 20.45 1.15 19.9 0.7 19.45 0 19.45 -0.7 19.45 -1.15 19.9 -1.65 20.45 -1.65 21.1 M -21.8 -1.2 Q -22.25 -0.7 -22.25 -0.05 -22.25 0.65 -21.8 1.15 -21.3 1.65 -20.6 1.65 -19.95 1.65 -19.4 1.15 -18.95 0.65 -18.95 -0.05 -18.95 -0.7 -19.4 -1.2 -19.95 -1.7 -20.6 -1.7 -21.3 -1.7 -21.8 -1.2 M 19.1 -1.2 Q 18.65 -0.7 18.65 -0.05 18.65 0.65 19.1 1.15 19.6 1.65 20.3 1.65 20.95 1.65 21.45 1.15 21.95 0.65 21.95 -0.05 21.95 -0.7 21.45 -1.2 20.95 -1.7 20.3 -1.7 19.6 -1.7 19.1 -1.2 M 1.65 -1.65 Q 0.95 -2.35 0 -2.35 -0.95 -2.35 -1.65 -1.65 -2.35 -1 -2.35 -0.05 -2.35 0.95 -1.65 1.65 -0.95 2.3 0 2.3 0.95 2.3 1.65 1.65 2.35 0.95 2.35 -0.05 2.35 -1 1.65 -1.65 M 0 -18.15 Q 0.7 -18.15 1.15 -18.6 1.65 -19.1 1.65 -19.8 1.65 -20.45 1.15 -20.95 0.7 -21.45 0 -21.45 -0.7 -21.45 -1.15 -20.95 -1.65 -20.45 -1.65 -19.8 -1.65 -19.1 -1.15 -18.6 -0.7 -18.15 0 -18.15 Z');
  ctx.translate(x,y);
  ctx.fillStyle = "#0088FF"
  ctx.fill(p);
  ctx.translate(-x,-y);
}

function renderCross(x,y){
  let p = new Path2D('M 16.4 10.5 L 14.5 8.65 12.6 10.55 10.7 8.65 8.8 10.5 10.7 12.45 8.8 14.35 10.7 16.25 12.6 14.3 14.5 16.25 16.4 14.35 14.5 12.45 16.4 10.5 Z');
  ctx.translate(x,y);
  ctx.fillStyle = "#0088FF"
  ctx.fill(p);
  ctx.translate(-x,-y);
}

function renderHealth(){
  if(lives <= 0){
    return;
  }
  var boardCenterX = gridOffSetX + (overallGridSize/2);
  var heartsRowWidth = ((lives-1) * HEART_SPACING) + HEART_ICON_WIDTH;
  var heartsStartX = boardCenterX - (heartsRowWidth/2);
  for(var livesCount = 0;livesCount<lives;livesCount++){
    renderHeart(heartsStartX + (livesCount*HEART_SPACING),gridOffSetY+overallGridSize+25);
  }
}

function renderHeart(x,y){
  let p = new Path2D('M 24.1 7.05 Q 24.1 4.65 22.4 2.95 21.4 1.95 20.1 1.55 19.25 1.25 18.3 1.25 15.9 1.25 14.2 2.95 12.55 4.6 12.5 7 12.45 4.6 10.8 2.95 9.15 1.3 6.85 1.25 6.8 1.25 6.7 1.25 4.3 1.25 2.6 2.95 0.9 4.65 0.9 7.05 0.9 9 2.15 10.65 L 12.5 23.8 22.3 11.75 Q 24.1 9.45 24.1 7.05 Z');
  ctx.translate(x,y);
  ctx.fillStyle = "#FF5555"
  ctx.fill(p);
  ctx.translate(-x,-y);
}

function renderOpponentHeart(x,y){
  let p = new Path2D('M 24.1 7.05 Q 24.1 4.65 22.4 2.95 21.4 1.95 20.1 1.55 19.25 1.25 18.3 1.25 15.9 1.25 14.2 2.95 12.55 4.6 12.5 7 12.45 4.6 10.8 2.95 9.15 1.3 6.85 1.25 6.8 1.25 6.7 1.25 4.3 1.25 2.6 2.95 0.9 4.65 0.9 7.05 0.9 9 2.15 10.65 L 12.5 23.8 22.3 11.75 Q 24.1 9.45 24.1 7.05 Z');
  ctx.translate(x,y);
  ctx.fillStyle = "#FF5555";
  ctx.fill(p);
  ctx.translate(-x,-y);
}

can.oncontextmenu = function (e) {
    e.preventDefault();
};

function renderMouseOver(){
  for(var i = 0; i<gridSize;i++){
    for(var j = 0; j<gridSize;j++){
      //check if mouse is over cell
      if(mouseX > i*cellSize+gridOffSetX && mouseX < i*cellSize+cellSize+gridOffSetX && mouseY > j*cellSize+gridOffSetY && mouseY < j*cellSize+cellSize+gridOffSetY){
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = "#0088FF";
        ctx.roundRect(i*cellSize+gridOffSetX,j*cellSize+gridOffSetY,cellSize,cellSize, 3,true,false);
      }
      ctx.globalAlpha = 1;
    }
  }
}

function renderBackdrop(){
  ctx.globalAlpha = 0.1;
  ctx.fillStyle = "#0088FF";
  ctx.roundRect(gridOffSetX-gridBoundaryMargin,gridOffSetY-gridBoundaryMargin,overallGridSize+(gridBoundaryMargin+15),overallGridSize+(gridBoundaryMargin+15), 5,true,false);
  ctx.globalAlpha = 1;
  ctx.strokeStyle = "#0088FF";
  ctx.lineWidth = .75;
  ctx.roundRect(gridOffSetX-gridBoundaryMargin,gridOffSetY-gridBoundaryMargin,overallGridSize+(gridBoundaryMargin+15),overallGridSize+(gridBoundaryMargin+15), 5,false,true);
}
function renderClueText(){
  for (var counts in Xcounters){
    for(var seg in Xcounters[counts]){
      ctx.font = "11px Arial";
      ctx.fillStyle = "#0088FF";
      ctx.fillText(Xcounters[counts][Xcounters[counts].length-seg-1], gridOffSetX+(cellSize/4)+(counts*cellSize), gridOffSetY-10-(seg*15));
    }
  }
  for (var counts in Ycounters){
    for(var seg in Ycounters[counts]){
      ctx.font = "11px Arial";
      ctx.fillStyle = "#0088FF";
      ctx.fillText(Ycounters[counts][Ycounters[counts].length-seg-1], gridOffSetX-(seg*15)-14, gridOffSetY+6+(cellSize/4)+(counts*cellSize));
    }
  }
}
sceneObjects = [];
function getPointerPosition(evt){
  var sourceEvent = evt;
  if(evt && evt.touches && evt.touches.length){
    sourceEvent = evt.touches[0];
  } else if(evt && evt.changedTouches && evt.changedTouches.length){
    sourceEvent = evt.changedTouches[0];
  }
  if(!sourceEvent){
    return;
  }
  mouseX = sourceEvent.clientX - can.offsetLeft;
  mouseY = sourceEvent.clientY - can.offsetTop;
}

function mouseMove(evt){
    getPointerPosition(evt);
    if(mouseState === "down"){
      sendActionFromPointerDrag(mouseButton);
    }
}
function gameOverScreen(){
    if(lives == 0){
      gameMode = "gameOver";
    }
}

function prunePendingPredictions(){
  if(!pendingPredictions || !pendingPredictions.length){
    return;
  }
  var now = Date.now();
  pendingPredictions = pendingPredictions.filter(function(action){
    return now - action.createdAt < 2000;
  });
  if(pendingPredictions.length > MAX_PENDING_PREDICTIONS){
    pendingPredictions = pendingPredictions.slice(pendingPredictions.length - MAX_PENDING_PREDICTIONS);
  }
}

function reconcilePendingPredictions(){
  if(!pendingPredictions || !pendingPredictions.length){
    return;
  }

  prunePendingPredictions();

  var remaining = [];
  for(var i = 0; i < pendingPredictions.length; i++){
    var action = pendingPredictions[i];
    if(!gridGuesses || !gridGuesses[action.x]){
      continue;
    }

    if(gridGuesses[action.x][action.y] === 1){
      continue;
    }

    applyLocalPrediction(action.x, action.y, action.button);
    remaining.push(action);
  }

  pendingPredictions = remaining;
}

function applyLocalPrediction(x, y, button){
  if(!grid || !gridGuesses || !grid[x] || !gridGuesses[x]){
    return;
  }

  if(grid[x][y] === 1 && gridGuesses[x][y] !== 1){
    gridGuesses[x][y] = 1;
    if(button !== 0){
      lives -= 1;
    } else {
      var columnGuesses = 0;
      var rowGuesses = 0;
      for(var k = 0; k < gridSize; k++){
        if(grid[x][k] === 1 && gridGuesses[x][k] === 1){
          columnGuesses += 1;
        }
        if(grid[k][y] === 1 && gridGuesses[k][y] === 1){
          rowGuesses += 1;
        }
      }
      if(columnGuesses === columnsTotal[x]){
        for(var l = 0; l < gridSize; l++){
          gridGuesses[x][l] = 1;
        }
      }
      if(rowGuesses === rowsTotal[y]){
        for(var m = 0; m < gridSize; m++){
          gridGuesses[m][y] = 1;
        }
      }
    }
  }

  if(grid[x][y] === 0 && gridGuesses[x][y] !== 1){
    gridGuesses[x][y] = 1;
    if(button !== 2){
      lives -= 1;
    }
  }

  if(lives <= 0){
    lives = 0;
    gameMode = "gameOver";
  }
}

function sendActionFromPointerDrag(button){
  if(gameMode != "play"){
    return;
  }
  for(var i = 0; i<gridSize;i++){
    for(var j = 0; j<gridSize;j++){
      if(mouseX > i*cellSize+gridOffSetX && mouseX < i*cellSize+cellSize+gridOffSetX && mouseY > j*cellSize+gridOffSetY && mouseY < j*cellSize+cellSize+gridOffSetY){
        if(lastDraggedCell && lastDraggedCell.x === i && lastDraggedCell.y === j && lastDraggedCell.button === button){
          return;
        }
        lastDraggedCell = { x: i, y: j, button: button };
        pendingPredictions.push({ x: i, y: j, button: button, createdAt: Date.now() });
        prunePendingPredictions();
        applyLocalPrediction(i, j, button);
        if(socket){
          socket.emit("game:action", { x: i, y: j, button: button });
        }
        return;
      }
    }
  }
}

function mouseDown(evt){
	getPointerPosition(evt);
	mouseState = "down";
	mouseButton = typeof evt.button === "number" ? evt.button : 0;
  lastDraggedCell = null;
  sendActionFromPointerDrag(mouseButton);
}
function mouseUp(evt){
	getPointerPosition(evt);
	mouseState = "up";
	mouseButton = evt && typeof evt.button === "number" ? evt.button : 0;
  lastDraggedCell = null;
}
var intervalID;
function requestMatch(){
  if(!socket){
    setMatchStatus("No server connection.");
    return;
  }
  pendingPredictions = [];
  gameMode = "waiting";
  setMatchStatus("Waiting for an opponent...");
  startButton.disabled = true;
  startButton.textContent = "Waiting...";
  socket.emit("matchmaking:join");
}

function click(evt){
  getPointerPosition(evt);
  if(evt.detail === 0 && gameMode == "play"){
    sendActionFromPointerDrag(0);
  }
}

function applyServerState(state){
  if(!state){
    return;
  }
  gameMode = state.gameMode;
  timer = state.timer;
  level = state.level;
  score = state.score;
  lives = state.lives;
  timeLimit = state.timeLimit;
  updateSharedClock(timer, timeLimit);
  gridSize = state.gridSize;
  grid = state.grid;
  gridGuesses = state.gridGuesses;
  Xcounters = state.Xcounters;
  Ycounters = state.Ycounters;
  columnsTotal = state.columnsTotal;
  rowsTotal = state.rowsTotal;

  reconcilePendingPredictions();

  if(gameMode !== "play") {
    pendingPredictions = [];
  }

  overallGridSize = gridSize*cellSize;
  gridOffSetX = 120;
  gridOffSetY = 120;
}

CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius, fill, stroke) {
    var cornerRadius = { upperLeft: 0, upperRight: 0, lowerLeft: 0, lowerRight: 0 };
    if (typeof stroke == "undefined") {
        stroke = true;
    }

    if (typeof radius === "object") {
        for (var side in radius) {
            cornerRadius[side] = radius[side];
        }
    }
  	if (typeof radius === "number"){
  		for (var side in cornerRadius) {
              cornerRadius[side] = radius;
          }
  	}

    this.beginPath();
    this.moveTo(x + cornerRadius.upperLeft, y);
    this.lineTo(x + width - cornerRadius.upperRight, y);
    this.quadraticCurveTo(x + width, y, x + width, y + cornerRadius.upperRight);
    this.lineTo(x + width, y + height - cornerRadius.lowerRight);
    this.quadraticCurveTo(x + width, y + height, x + width - cornerRadius.lowerRight, y + height);
    this.lineTo(x + cornerRadius.lowerLeft, y + height);
    this.quadraticCurveTo(x, y + height, x, y + height - cornerRadius.lowerLeft);
    this.lineTo(x, y + cornerRadius.upperLeft);
    this.quadraticCurveTo(x, y, x + cornerRadius.upperLeft, y);
    this.closePath();
    if (stroke) {
        this.stroke();
    }
    if (fill) {
        this.fill();
    }
}
var Xcounters = [];
var Ycounters = [];
var columnsTotal = [];
var rowsTotal = [];

function initGrid(){
	//reset main values
	grid = [];
	gridGuesses = [];
	Xcounters = [];
	Ycounters = [];
	columnsTotal = [];
	rowsTotal = [];

  for(var i = 0; i<this.gridSize;i++){
    var gridX = [];
    var gridGuessesX = [];
    for(var j = 0; j<this.gridSize;j++){
      var randomNumber = Math.floor(Math.random()*3);
      if (randomNumber>1){randomNumber=1;}
      gridX.push(randomNumber);
      gridGuessesX.push(0);
    }
    grid.push(gridX);
    gridGuesses.push(gridGuessesX);
  }

  //builds clues and row column total arrays
  for(var i = 0; i<this.gridSize;i++){
    var column = [];
    var count = 0;
	var countTotal =0;
    for(var j = 0; j<this.gridSize;j++){
      if(grid[i][j] == 1){
        count ++;
		countTotal ++;
      } else {
        if(count > 0){
          column.push(count);
          count = 0;
        }
      }
    }
    if(count > 0){
      column.push(count);
    }
	columnsTotal.push(countTotal);
    Xcounters.push(column);
  }
  for(var i = 0; i<this.gridSize;i++){
    var row = [];
    var count = 0
	var countTotal = 0;
    for(var j = 0; j<this.gridSize;j++){
      if(grid[j][i] == 1){
        count ++;
		countTotal ++;
        if(j == this.gridSize-1){
          row.push(count);
        }
      } else {
        if(count != 0){
          row.push(count);
          count = 0;
        }
      }
    }
	rowsTotal.push(countTotal);
    Ycounters.push(row);
  }
}

function renderCells(){
  for(var i = 0; i<this.gridSize;i++){
    for(var j = 0; j<this.gridSize;j++){
      ctx.lineWidth = 1;
      ctx.strokeStyle = "#0088FF";
      ctx.fillStyle = "#FFFFFF";
      ctx.roundRect(i*cellSize+gridOffSetX,j*cellSize+gridOffSetY,cellSize,cellSize, 3,true,true);
      if(gridGuesses[i][j] == 1 && grid[i][j] == 1){
        ctx.fillStyle = "#0088FF";
        ctx.roundRect(i*cellSize+gridOffSetX,j*cellSize+gridOffSetY,cellSize,cellSize, 3,true,false);
      }
      if(gridGuesses[i][j] == 1 && grid[i][j] == 0){
        renderCross(i*cellSize+gridOffSetX-3,j*cellSize+gridOffSetY-3);
      }
    }
  }
}


startButton.addEventListener("click", function(){
  var requestedName = playerNameInput.value && playerNameInput.value.trim();
  if(requestedName){
    myPlayerName = requestedName.slice(0,24);
    myDisplayName = myPlayerName;
  }
  sendPlayerUpdate();
  if(gameMode === "gameOver" && socket){
    socket.emit("game:restart");
    startButton.disabled = true;
    startButton.textContent = "Waiting...";
    setMatchStatus("Rematch requested. Waiting for opponent...");
    return;
  }
  requestMatch();
});

playerNameInput.addEventListener("change", function(){
  var requestedName = playerNameInput.value && playerNameInput.value.trim();
  if(requestedName){
    myPlayerName = requestedName.slice(0,24);
    myDisplayName = myPlayerName;
    sendPlayerUpdate();
  }
});

init();
initMultiplayer();

</script>

</html>
