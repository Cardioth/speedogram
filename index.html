<!DOCTYPE html>
<html>
<title>Speed-o-Gram</title>
<style>
  :root {
    --bg-1: #070b1c;
    --bg-2: #11183a;
    --panel: rgba(16, 25, 58, 0.78);
    --panel-border: rgba(127, 182, 255, 0.35);
    --accent: #52b6ff;
    --accent-strong: #1d90ff;
    --text: #e8f2ff;
    --text-muted: #9cb7d8;
    --shadow: 0 20px 60px rgba(3, 8, 30, 0.55);
  }
  body {
    margin: 0;
    min-height: 100vh;
    font-family: "Inter", "Segoe UI", Arial, sans-serif;
    color: var(--text);
    position: relative;
    overflow: hidden;
    background:
      radial-gradient(circle at 12% 20%, rgba(64, 144, 255, 0.24), transparent 34%),
      radial-gradient(circle at 85% 12%, rgba(120, 88, 255, 0.22), transparent 28%),
      linear-gradient(150deg, var(--bg-1), var(--bg-2));
    background-size: 145% 145%, 155% 155%, 100% 100%;
    animation: bgShift 18s ease-in-out infinite alternate;
  }
  body::before {
    content: "";
    position: fixed;
    inset: 0;
    pointer-events: none;
    background-image: linear-gradient(rgba(135, 192, 255, 0.09) 1px, transparent 1px), linear-gradient(90deg, rgba(135, 192, 255, 0.09) 1px, transparent 1px);
    background-size: 42px 42px;
    opacity: 0.68;
    animation: gridDrift 22s linear infinite;
  }
  body::after {
    content: "";
    position: fixed;
    inset: -18% -10%;
    pointer-events: none;
    background:
      radial-gradient(circle at 18% 22%, rgba(64, 144, 255, 0.36), transparent 40%),
      radial-gradient(circle at 80% 20%, rgba(120, 88, 255, 0.33), transparent 42%),
      radial-gradient(circle at 56% 80%, rgba(58, 134, 255, 0.2), transparent 36%);
    filter: blur(14px);
    opacity: 0.88;
    transform-origin: center;
    animation: auroraPulse 10s ease-in-out infinite alternate, auroraDrift 24s ease-in-out infinite;
    z-index: -1;
  }
  @keyframes bgShift {
    0% {
      background-position: 0% 0%, 100% 0%, 50% 50%;
    }
    100% {
      background-position: 20% 14%, 84% 18%, 50% 50%;
    }
  }
  @keyframes auroraPulse {
    0% {
      opacity: 0.58;
      transform: scale(1);
    }
    100% {
      opacity: 0.92;
      transform: scale(1.08);
    }
  }
  @keyframes auroraDrift {
    0% {
      transform: translate3d(-1%, 0%, 0) rotate(0deg);
    }
    50% {
      transform: translate3d(2%, -2%, 0) rotate(1.2deg);
    }
    100% {
      transform: translate3d(-1%, 1%, 0) rotate(-1deg);
    }
  }
  @keyframes gridDrift {
    0% {
      background-position: 0 0, 0 0;
      opacity: 0.62;
    }
    50% {
      opacity: 0.78;
    }
    100% {
      background-position: 42px 42px, 42px 42px;
      opacity: 0.66;
    }
  }
  #appHeader {
    width: min(960px, calc(100vw - 32px));
    margin: 20px auto 10px;
    padding: 10px 0 14px;
    text-align: center;
    color: var(--text);
  }
  #appTitle {
    margin: 0;
    font-size: clamp(30px, 4.2vw, 42px);
    line-height: 1;
    letter-spacing: 1px;
    text-shadow: 0 0 18px rgba(76, 173, 255, 0.45);
  }
  #appVersion {
    margin-top: 8px;
    font-size: 12px;
    color: var(--text-muted);
    letter-spacing: 0.7px;
    text-transform: uppercase;
  }
  #arena {
    width: min(960px, calc(100vw - 32px));
    margin: 12px auto 0;
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: center;
    position: relative;
  }
  #speedogram {
    display: block;
    width: min(900px, calc(100vw - 42px));
    height: auto;
    border-radius: 16px;
    background: linear-gradient(160deg, rgba(11, 20, 48, 0.93), rgba(9, 16, 38, 0.95));
    box-shadow: var(--shadow);
    border: 1px solid var(--panel-border);
  }
  .hidden {
    display: none !important;
  }
  #controls {
    width: min(960px, calc(100vw - 32px));
    margin: 16px auto 10px;
    display: flex;
    gap: 10px;
    align-items: center;
    justify-content: center;
    color: var(--text);
  }
  #playerName {
    border: 1px solid rgba(130, 183, 255, 0.55);
    border-radius: 12px;
    padding: 10px 12px;
    min-width: 180px;
    background: rgba(10, 20, 50, 0.75);
    color: var(--text);
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
  }
  #playerName::placeholder {
    color: #8ea5c2;
  }
  #startButton {
    border: 1px solid rgba(148, 201, 255, 0.7);
    background: linear-gradient(180deg, #59c1ff 0%, #2199ff 100%);
    border-radius: 12px;
    color: #f7fcff;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    font-weight: 600;
    padding: 10px 16px;
    cursor: pointer;
    box-shadow: 0 8px 20px rgba(38, 144, 255, 0.35);
  }
  #startButton:disabled {
    cursor: not-allowed;
    opacity: 0.65;
  }
  #soundToggleButton {
    border: 1px solid rgba(130, 183, 255, 0.55);
    border-radius: 12px;
    padding: 8px 10px;
    background: rgba(10, 20, 50, 0.75);
    color: var(--text);
    cursor: pointer;
    font-weight: 600;
    letter-spacing: 0.3px;
    font-size: 18px;
    line-height: 1;
  }
  #soundControls {
    position: fixed;
    top: 12px;
    right: 12px;
    z-index: 30;
  }
  #nameStatus,
  #matchStatus,
  #multiplayerPlayers {
    font-size: 13px;
    line-height: 1.4;
  }
  #multiplayerPanel {
    width: min(900px, calc(100vw - 42px));
    margin: 14px auto 0;
    color: var(--text);
    display: flex;
    gap: 12px;
    align-items: flex-start;
    justify-content: center;
    flex-wrap: wrap;
  }
  .infoCard {
    border: 1px solid var(--panel-border);
    border-radius: 14px;
    background: var(--panel);
    backdrop-filter: blur(4px);
    padding: 10px 12px;
    width: calc((100% - 12px) / 2);
    min-height: 74px;
    box-shadow: var(--shadow);
    box-sizing: border-box;
  }
  #helpLinkWrap {
    width: 900px;
    margin: 12px auto 0;
    text-align: center;
  }
  #helpLink {
    color: #9bd2ff;
    font-size: 14px;
    text-decoration: none;
    cursor: pointer;
    border-bottom: 1px dashed rgba(155, 210, 255, 0.6);
    padding-bottom: 2px;
  }
  #helpModal {
    position: fixed;
    inset: 0;
    background: rgba(6, 12, 28, 0.76);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }
  #helpModal.hidden {
    display: none;
  }
  #helpModalCard {
    background: linear-gradient(160deg, #0f1940, #101835);
    border: 1px solid var(--panel-border);
    border-radius: 14px;
    width: min(640px, calc(100vw - 40px));
    padding: 18px 20px;
    box-shadow: var(--shadow);
    color: var(--text);
  }
  #helpModalCard h3 {
    margin: 0 0 10px;
    color: #9dd6ff;
  }
  #helpModalText {
    font-size: 14px;
    line-height: 1.55;
    color: #d7eaff;
  }
  .helpSection {
    margin-top: 14px;
    padding: 10px 12px;
    border: 1px solid rgba(125, 180, 255, 0.28);
    border-radius: 10px;
    background: rgba(13, 23, 53, 0.55);
  }
  .helpSection:first-child {
    margin-top: 0;
  }
  .helpSectionTitle {
    margin: 0 0 8px;
    font-size: 14px;
    font-weight: 700;
    letter-spacing: 0.3px;
    color: #8fd0ff;
  }
  .helpSection ul {
    margin: 0;
    padding-left: 18px;
  }
  .helpSection li {
    margin-bottom: 6px;
  }
  .helpSection li:last-child {
    margin-bottom: 0;
  }
  .helpLabel {
    color: #ffffff;
    font-weight: 600;
  }
  #helpDemo {
    margin-top: 14px;
    padding: 12px;
    border: 1px solid #d6ebff;
    border-radius: 8px;
    background: linear-gradient(180deg, #f7fbff 0%, #ffffff 100%);
  }
  #helpDemoTitle {
    margin: 0 0 8px;
    font-size: 13px;
    font-weight: bold;
    color: #0077dc;
  }
  #helpDemoBoard {
    width: 168px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: 30px repeat(3, 34px);
    grid-template-rows: 30px repeat(3, 34px);
    gap: 2px;
    align-items: center;
    justify-items: center;
  }
  .demoAxisLabel {
    font-size: 11px;
    color: #2c8fe3;
    font-weight: bold;
  }
  .demoCell {
    width: 32px;
    height: 32px;
    border: 1px solid #8cc6ff;
    border-radius: 6px;
    background: #ffffff;
    position: relative;
    transition: background-color 200ms ease, border-color 200ms ease, transform 200ms ease;
  }
  .demoCell::before,
  .demoCell::after {
    content: "";
    position: absolute;
    left: 7px;
    top: 15px;
    width: 18px;
    height: 2px;
    background: #8aa8c8;
    opacity: 0;
    transition: opacity 160ms ease;
    border-radius: 2px;
  }
  .demoCell::before {
    transform: rotate(45deg);
  }
  .demoCell::after {
    transform: rotate(-45deg);
  }
  .demoCell.isFilled {
    background: #0088FF;
    border-color: #0077dc;
    transform: scale(0.96);
  }
  .demoCell.isMarked::before,
  .demoCell.isMarked::after {
    opacity: 1;
  }
  #helpDemoCaption {
    margin: 10px 0 0;
    text-align: center;
    font-size: 12px;
    color: #9fc3e8;
  }
  #closeHelpButton {
    margin-top: 14px;
    border: 1px solid rgba(148, 201, 255, 0.7);
    background: linear-gradient(180deg, #59c1ff 0%, #2199ff 100%);
    border-radius: 10px;
    color: #f5fbff;
    padding: 6px 12px;
    cursor: pointer;
  }
  #multiplayerPanel h3 {
    margin: 0 0 6px;
    font-size: 16px;
  }
  #multiplayerPlayers,
  #leaderboardPlayers {
    font-size: 13px;
    line-height: 1.4;
  }
  #shopPanel {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: min(760px, calc(100% - 60px));
    text-align: center;
    color: var(--text);
    font-size: 13px;
    z-index: 3;
    background: #0f1940;
    border: 1px solid rgba(127, 182, 255, 0.7);
    border-radius: 16px;
    padding: 18px 16px;
    box-shadow: 0 20px 40px rgba(3, 8, 30, 0.7);
  }
  #shopTitle {
    margin-bottom: 4px;
    font-size: 16px;
    letter-spacing: 0.3px;
  }
  #shopPoints {
    margin-bottom: 12px;
    color: #a9d8ff;
    font-size: 13px;
  }
  #shopChoices {
    display: flex;
    justify-content: center;
    gap: 14px;
    flex-wrap: wrap;
  }
  .shopChoiceBtn {
    border: 1px solid rgba(110, 154, 220, 0.45);
    background: rgba(17, 27, 58, 0.96);
    border-radius: 14px;
    color: #dbeaff;
    width: 190px;
    height: 190px;
    padding: 0;
    cursor: pointer;
    position: relative;
    font-size: 14px;
    line-height: 1.35;
    box-shadow: 0 10px 20px rgba(4, 10, 34, 0.45);
  }
  .shopChoiceBtn .shopChoiceIcon {
    position: absolute;
    top: 42%;
    left: 50%;
    width: 56px;
    height: 56px;
    transform: translate(-50%, -50%);
    color: var(--accent);
  }
  .shopChoiceBtn .shopChoiceIcon::before {
    content: "";
    position: absolute;
    inset: 0;
    background: currentColor;
    border-radius: 42% 58% 52% 48% / 56% 42% 58% 44%;
    opacity: 0.95;
  }
  .shopChoiceBtn .shopChoiceText {
    position: absolute;
    top: 72%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: block;
    max-width: 160px;
    text-align: center;
    font-size: 13px;
    line-height: 1.3;
    font-weight: 600;
    color: #d5e8ff;
  }
  .shopChoiceBtn .shopChoiceCost {
    position: absolute;
    top: 12px;
    right: 12px;
    font-size: 11px;
    letter-spacing: 0.6px;
    text-transform: uppercase;
    font-weight: 800;
    border-radius: 999px;
    padding: 4px 10px;
    border: 1px solid rgba(156, 196, 255, 0.5);
    color: #b7d7ff;
    background: rgba(48, 78, 126, 0.38);
  }
  .shopChoiceBtn .shopChoiceTier {
    position: absolute;
    top: 12px;
    left: 12px;
    font-size: 11px;
    letter-spacing: 1px;
    text-transform: uppercase;
    font-weight: 800;
    border-radius: 999px;
    padding: 4px 10px;
    border: 1px solid transparent;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
  }
  .shopChoiceBtn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  .shopChoiceBtn--common {
    border-color: rgba(125, 145, 182, 0.78);
    background: linear-gradient(180deg, rgba(49, 63, 92, 0.95), rgba(37, 49, 76, 0.95));
  }
  .shopChoiceBtn--common .shopChoiceIcon {
    color: #a8bddf;
  }
  .shopChoiceBtn--common .shopChoiceTier {
    background: rgba(168, 189, 223, 0.16);
    border-color: rgba(168, 189, 223, 0.46);
    color: #c8d9f3;
  }
  .shopChoiceBtn--rare {
    border-color: rgba(96, 173, 255, 0.92);
    background: linear-gradient(180deg, rgba(24, 56, 104, 0.96), rgba(18, 41, 82, 0.96));
  }
  .shopChoiceBtn--rare .shopChoiceIcon {
    color: #61b5ff;
  }
  .shopChoiceBtn--rare .shopChoiceTier {
    background: rgba(97, 181, 255, 0.2);
    border-color: rgba(97, 181, 255, 0.55);
    color: #8fd0ff;
  }
  .shopChoiceBtn--epic {
    border-color: rgba(198, 132, 255, 0.95);
    background: linear-gradient(180deg, rgba(67, 34, 104, 0.96), rgba(50, 24, 85, 0.96));
  }
  .shopChoiceBtn--epic .shopChoiceIcon {
    color: #c888ff;
  }
  .shopChoiceBtn--epic .shopChoiceTier {
    background: rgba(200, 136, 255, 0.2);
    border-color: rgba(200, 136, 255, 0.54);
    color: #dfbeff;
  }
  #matchStatus {
    color: var(--text-muted) !important;
    letter-spacing: 0.2px;
  }
  @media (max-width: 960px) {
    .infoCard {
      width: 100%;
    }
  }
</style>
<body>
  <div id="appHeader">
    <h1 id="appTitle">Speed-o-Gram</h1>
    <div id="appVersion"></div>
  </div>
  <div id="controls" class="matchmakingUI">
    <input id="playerName" maxlength="24" placeholder="Player name" />
    <button id="startButton">Start</button>
  </div>
  <div id="soundControls">
    <button id="soundToggleButton" type="button" aria-pressed="false" aria-label="Mute sound">üîä</button>
  </div>
  <div id="matchStatus" class="matchmakingUI" style="text-align:center;color:#0088FF;font-size:13px;">Enter your name and click Start.</div>
    <div id="arena">
    <canvas id="speedogram" width="900" height="440">Hello</canvas>
    <div id="shopPanel" class="hidden">
      <div id="shopTitle">Round shop</div>
      <div id="shopPoints">0 shop points to spend</div>
      <div id="shopChoices"></div>
    </div>
  </div>
  <div id="multiplayerPanel">
    <div class="infoCard">
      <h3>Live Players</h3>
      <div id="multiplayerPlayers">Waiting for players‚Ä¶</div>
    </div>
    <div class="infoCard">
      <h3>Daily Leaderboard</h3>
      <div id="leaderboardPlayers">No daily scores yet.</div>
    </div>
  </div>
  <div id="helpLinkWrap">
    <a id="helpLink" href="#">How to Play</a>
  </div>

  <div id="helpModal" class="hidden" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
    <div id="helpModalCard">
      <h3 id="helpModalTitle">How to Play</h3>
      <div id="helpDemo" aria-hidden="true">
        <p id="helpDemoTitle">Example: watch this 3√ó3 puzzle being solved</p>
        <div id="helpDemoBoard">
          <span></span>
          <span class="demoAxisLabel">3</span>
          <span class="demoAxisLabel">1</span>
          <span class="demoAxisLabel">1</span>
          <span class="demoAxisLabel">2</span>
          <div class="demoCell" data-demo-cell="0"></div>
          <div class="demoCell" data-demo-cell="1"></div>
          <div class="demoCell" data-demo-cell="2"></div>
          <span class="demoAxisLabel">1</span>
          <div class="demoCell" data-demo-cell="3"></div>
          <div class="demoCell" data-demo-cell="4"></div>
          <div class="demoCell" data-demo-cell="5"></div>
          <span class="demoAxisLabel">1 1</span>
          <div class="demoCell" data-demo-cell="6"></div>
          <div class="demoCell" data-demo-cell="7"></div>
          <div class="demoCell" data-demo-cell="8"></div>
        </div>
        <p id="helpDemoCaption">Blue squares are filled. Gray X marks ruled-out cells.</p>
      </div>
      <div id="helpModalText">
        <section class="helpSection">
          <h4 class="helpSectionTitle">‚ö° QUICK START</h4>
          <ul>
            <li>Clear the board faster than your opponents!</li>
            <li><span class="helpLabel">Numbers:</span> Show the size of Black Blocks in that row/column.</li>
            <li><span class="helpLabel">Multiple Numbers:</span> (e.g., 2 4) means a gap of at least one space between blocks.</li>
            <li><span class="helpLabel">The Win:</span> Fill every Black Square to clear the board.</li>
          </ul>
        </section>
        <section class="helpSection">
          <h4 class="helpSectionTitle">‚å®Ô∏è CONTROLS</h4>
          <ul>
            <li><span class="helpLabel">Left Click:</span> Fill Black</li>
            <li><span class="helpLabel">Right Click:</span> Mark X (Use these! Don't guess.)</li>
            <li><span class="helpLabel">Click + Drag:</span> Paint multiple squares instantly.</li>
          </ul>
        </section>
        <section class="helpSection">
          <h4 class="helpSectionTitle">üöÄ FAST-PLAY TIPS</h4>
          <ul>
            <li><span class="helpLabel">Total Fill:</span> If the numbers add up to the grid size (including gaps), it's a freebie. Fill it.</li>
            <li><span class="helpLabel">Don't Guess:</span> One wrong click in multiplayer is a death sentence. Use X to narrow it down.</li>
          </ul>
        </section>
      </div>
      <button id="closeHelpButton" type="button">Close</button>
    </div>
  </div>
</body>

<script src="/socket.io/socket.io.js"></script>
<script>
var versionNumber = "V0.1"
var CANVAS_ACCENT = "#52b6ff";
var CANVAS_ACCENT_STRONG = "#1d90ff";
var CANVAS_CELL_BG = "#0f1c45";
var CANVAS_TEXT = "#dff1ff";
var CANVAS_DANGER = "#ff6f7d";
var canvas = document.getElementById('speedogram');
var canvasSize = canvas.width;
var height = canvas.height;
var totalLives = 3;
var lives = totalLives;
var gridSize = 3;
var level = 0;
var gridSizeIntervals = [3,3,3,4,4,4,5,5,5,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,9,9,10,10];
var cellSize = 22;
var gridBoundaryMargin = 76;
var overallGridSize = gridSize*cellSize;
var gridOffSetX = 120;
var gridOffSetY = 120;
var mouseState = "up";
var mouseButton;
var timer;
var timerState = "stopped";
var timeLimitInit = 12000;
var timeLimit = timeLimitInit;
var timeIncrement = 700;
var score = 0;
var shopPoints = 0;
var currentRound = 1;
var totalRounds = 5;
var winnerText = "";
var lastPlaySecondsRemaining = null;

function getOrCreateLocalPlayerId(){
  var storageKey = "speedogram.playerId";
  var existing = "";
  try {
    existing = localStorage.getItem(storageKey) || "";
  } catch (_error) {
    existing = "";
  }
  if(existing && /^[a-zA-Z0-9_-]{8,48}$/.test(existing)){
    return existing;
  }
  var generated = "p_" + Math.random().toString(36).slice(2) + Date.now().toString(36);
  generated = generated.replace(/[^a-zA-Z0-9_-]/g, "").slice(0, 48);
  if(generated.length < 8){
    generated = (generated + "speedogram").slice(0, 8);
  }
  try {
    localStorage.setItem(storageKey, generated);
  } catch (_error) {
    // Ignore storage failures (private browsing, disabled storage, etc.)
  }
  return generated;
}

var stablePlayerId = getOrCreateLocalPlayerId();
var socket = typeof io !== "undefined" ? io({ auth: { playerId: stablePlayerId } }) : null;
var myPlayerName = "";
var latestRoster = [];
var latestLeaderboard = [];
var startButton = document.getElementById("startButton");
var soundToggleButton = document.getElementById("soundToggleButton");
var playerNameInput = document.getElementById("playerName");
var matchStatusEl = document.getElementById("matchStatus");
var opponentState = null;
var appVersionEl = document.getElementById("appVersion");
var opponentGridOffSetX = 560;
var boardTopY = 120;
var myDisplayName = "You";
var opponentDisplayName = "Opponent";
var pendingPredictions = [];
var MAX_PENDING_PREDICTIONS = 64;
var currentPuzzleId = 0;
var HEART_ICON_WIDTH = 24;
var HEART_SPACING = 25;
var lastDraggedCell = null;
var countdownRemaining = 0;
var helpLink = document.getElementById("helpLink");
var helpModal = document.getElementById("helpModal");
var closeHelpButton = document.getElementById("closeHelpButton");
var helpDemoCells = Array.prototype.slice.call(document.querySelectorAll("[data-demo-cell]"));
var helpDemoTimer = null;
var helpDemoStep = 0;
var helpDemoFrames = [
  { index: 0, state: "fill" },
  { index: 1, state: "fill" },
  { index: 2, state: "mark" },
  { index: 3, state: "fill" },
  { index: 4, state: "mark" },
  { index: 5, state: "mark" },
  { index: 6, state: "fill" },
  { index: 7, state: "mark" },
  { index: 8, state: "fill" },
  { state: "pause" },
  { state: "reset" }
];

function resetHelpDemoBoard(){
  for(var i = 0; i < helpDemoCells.length; i++){
    helpDemoCells[i].classList.remove("isFilled", "isMarked");
  }
}

function playHelpDemoFrame(){
  var frame = helpDemoFrames[helpDemoStep];
  if(!frame){
    helpDemoStep = 0;
    return;
  }
  if(frame.state === "fill" && helpDemoCells[frame.index]){
    helpDemoCells[frame.index].classList.remove("isMarked");
    helpDemoCells[frame.index].classList.add("isFilled");
  }
  if(frame.state === "mark" && helpDemoCells[frame.index]){
    helpDemoCells[frame.index].classList.remove("isFilled");
    helpDemoCells[frame.index].classList.add("isMarked");
  }
  if(frame.state === "reset"){
    resetHelpDemoBoard();
  }
  helpDemoStep = (helpDemoStep + 1) % helpDemoFrames.length;
}

function setHelpDemoRunning(shouldRun){
  if(helpDemoTimer){
    clearInterval(helpDemoTimer);
    helpDemoTimer = null;
  }
  if(!shouldRun || !helpDemoCells.length){
    return;
  }
  helpDemoStep = 0;
  resetHelpDemoBoard();
  playHelpDemoFrame();
  helpDemoTimer = setInterval(playHelpDemoFrame, 520);
}

function setHelpModalVisible(visible){
  if(!helpModal){
    return;
  }
  helpModal.classList.toggle("hidden", !visible);
  setHelpDemoRunning(visible);
}
var shopPanel = document.getElementById("shopPanel");
var shopChoicesEl = document.getElementById("shopChoices");
var shopTitleEl = document.getElementById("shopTitle");
var shopPointsEl = document.getElementById("shopPoints");
var shopOptions = [];
var hasPurchasedThisShop = false;
var lastShopRenderKey = "";
var soundStorageKey = "speedogram.soundEnabled";
var soundEnabled = true;
var sounds = {
  cellFilled: makeSound("/assets/sfx/cell-filled.ogg", 0.35),
  countdownBoop: makeSound("/assets/sfx/countdown-boop.ogg", 0.45),
  puzzleCompleted: makeSound("/assets/sfx/puzzle-completed.ogg", 0.45),
  clockTick: makeSound("/assets/sfx/clock-tick.ogg", 0.25),
  roundOver: makeSound("/assets/sfx/round-over.ogg", 0.45)
};

function makeSound(src, volume){
  var audio = new Audio(src);
  audio.preload = "auto";
  audio.volume = volume;
  return audio;
}

function loadSoundPreference(){
  try {
    var stored = localStorage.getItem(soundStorageKey);
    if(stored === "0"){
      soundEnabled = false;
    }
  } catch (_error) {
    soundEnabled = true;
  }
}

function persistSoundPreference(){
  try {
    localStorage.setItem(soundStorageKey, soundEnabled ? "1" : "0");
  } catch (_error) {
    // Ignore storage failures.
  }
}

function syncSoundButton(){
  if(!soundToggleButton){
    return;
  }
  soundToggleButton.textContent = soundEnabled ? "üîä" : "üîá";
  soundToggleButton.setAttribute("aria-label", soundEnabled ? "Mute sound" : "Unmute sound");
  soundToggleButton.setAttribute("aria-pressed", soundEnabled ? "false" : "true");
}

function playSound(soundKey){
  if(!soundEnabled){
    return;
  }
  var sound = sounds[soundKey];
  if(!sound){
    return;
  }
  try {
    var shot = sound.cloneNode(true);
    shot.volume = sound.volume;
    shot.play().catch(function(){
      // Ignore autoplay/user gesture errors.
    });
  } catch (_error) {
    // Ignore audio playback failures.
  }
}

function updateMultiplayerPanel(players){
  var panel = document.getElementById("multiplayerPlayers");
  if(!panel){
    return;
  }
  latestRoster = players || [];
  if(!latestRoster.length){
    panel.textContent = "Waiting for players‚Ä¶";
    return;
  }
  panel.innerHTML = latestRoster
    .map(function(player){
      return player.name + " ‚Äî score " + (player.score || 0) + ", shop " + (player.shopPoints || 0) + ", lvl " + player.level + ", lives " + player.lives + " (" + player.gameMode + ")";
    })
    .join("<br>");
}


function updateLeaderboardPanel(entries){
  var panel = document.getElementById("leaderboardPlayers");
  if(!panel){
    return;
  }
  latestLeaderboard = entries || [];
  if(!latestLeaderboard.length){
    panel.textContent = "No daily scores yet.";
    return;
  }
  panel.innerHTML = latestLeaderboard
    .map(function(entry){
      return "#" + entry.rank + " " + entry.name + " ‚Äî score " + (entry.bestPoints || 0);
    })
    .join("<br>");
}

function setShopVisible(visible){
  if(!shopPanel){
    return;
  }
  shopPanel.classList.toggle("hidden", !visible);
}

function renderShopChoices(){
  if(!shopChoicesEl){
    return;
  }
  shopChoicesEl.innerHTML = "";
  if(!shopOptions || !shopOptions.length || hasPurchasedThisShop){
    return;
  }
  for(var i = 0; i < shopOptions.length; i++){
    (function(option){
      var button = document.createElement("button");
      button.className = "shopChoiceBtn";
      if(option.tier){
        button.classList.add("shopChoiceBtn--" + option.tier);
      }
      var tierLabel = document.createElement("span");
      tierLabel.className = "shopChoiceTier";
      tierLabel.textContent = option.tierLabel || (option.tier ? option.tier.toUpperCase() : "UPGRADE");
      var iconPlaceholder = document.createElement("span");
      iconPlaceholder.className = "shopChoiceIcon";
      var label = document.createElement("span");
      label.className = "shopChoiceText";
      var optionCost = Number.isFinite(option.cost) ? option.cost : 0;
      var effectLabel = option.effectText || option.label || "Upgrade";
      label.textContent = effectLabel;
      var costLabel = document.createElement("span");
      costLabel.className = "shopChoiceCost";
      costLabel.textContent = optionCost + " pts";
      button.appendChild(tierLabel);
      button.appendChild(iconPlaceholder);
      button.appendChild(label);
      button.appendChild(costLabel);
      var canAfford = shopPoints >= optionCost;
      button.disabled = !!hasPurchasedThisShop || !canAfford;
      button.addEventListener("click", function(){
        if(!socket || hasPurchasedThisShop || !canAfford){
          return;
        }
        socket.emit("shop:buy", { upgradeId: option.id });
      });
      shopChoicesEl.appendChild(button);
    })(shopOptions[i]);
  }
}

function updateShopChoicesIfNeeded(){
  var optionsKey = (shopOptions || []).map(function(option){
    return option.id + ":" + option.cost;
  }).join("|");
  var nextRenderKey = optionsKey + "::" + shopPoints + "::" + (hasPurchasedThisShop ? "1" : "0");
  if(nextRenderKey === lastShopRenderKey){
    return;
  }
  lastShopRenderKey = nextRenderKey;
  renderShopChoices();
}

function sendPlayerUpdate(){
  if(!socket){
    return;
  }
  socket.emit("player:set-name", { name: myPlayerName });
}

function setMatchStatus(text){
  if(matchStatusEl){
    matchStatusEl.textContent = text;
  }
}


function setMatchmakingVisible(visible){
  var elements = document.querySelectorAll(".matchmakingUI");
  for(var i = 0; i < elements.length; i++){
    elements[i].classList.toggle("hidden", !visible);
  }
}

function updateBoardLayout(){
  overallGridSize = gridSize * cellSize;
  var opponentGridSizeLayout = (opponentState && opponentState.gridSize) ? opponentState.gridSize : gridSize;
  var opponentOverallGridSize = opponentGridSizeLayout * cellSize;
  var timerCenterX = canvas.width / 2;

  var myOuterWidth = overallGridSize + (gridBoundaryMargin + 15);
  var opponentOuterWidth = opponentOverallGridSize + (gridBoundaryMargin + 15);
  var desiredBoardGap = 220;
  var minimumBoardGap = 120;
  var maxBoardGap = Math.max(minimumBoardGap, canvas.width - myOuterWidth - opponentOuterWidth - 20);
  var boardGap = Math.max(minimumBoardGap, Math.min(desiredBoardGap, maxBoardGap));

  var myOuterCenterX = timerCenterX - (boardGap / 2) - (myOuterWidth / 2);
  var opponentOuterCenterX = timerCenterX + (boardGap / 2) + (opponentOuterWidth / 2);

  gridOffSetX = Math.round(myOuterCenterX + gridBoundaryMargin - (myOuterWidth / 2));
  opponentGridOffSetX = Math.round(opponentOuterCenterX + gridBoundaryMargin - (opponentOuterWidth / 2));
  gridOffSetY = boardTopY;

  var myOuterLeft = gridOffSetX - gridBoundaryMargin;
  var opponentOuterLeft = opponentGridOffSetX - gridBoundaryMargin;

  return {
    timerCenterX: timerCenterX,
    opponentGridSize: opponentGridSizeLayout,
    opponentOverallGridSize: opponentOverallGridSize,
    myOuterLeft: myOuterLeft,
    myOuterWidth: myOuterWidth,
    opponentOuterLeft: opponentOuterLeft,
    opponentOuterWidth: opponentOuterWidth
  };
}

function getOuterBoardCenterX(gridOffsetX, boardPixelSize){
  var outerX = gridOffsetX - gridBoundaryMargin;
  var outerWidth = boardPixelSize + (gridBoundaryMargin + 15);
  return outerX + (outerWidth / 2);
}

function getRemainingCentiseconds(currentTimer, limit){
  if(!Number.isFinite(currentTimer) || !Number.isFinite(limit) || limit <= 0){
    return null;
  }
  return Math.max(0, Math.ceil((limit - currentTimer) / 100));
}

function formatClockLabel(remainingCentiseconds){
  if(!Number.isFinite(remainingCentiseconds)){
    return "--.-s";
  }
  return (remainingCentiseconds / 10).toFixed(1) + "s";
}

var boardClockFacePath = new Path2D('M 8.5 -38.9 Q 7.95 -39.45 7.2 -39.45 L -7.95 -39.45 Q -8.75 -39.45 -9.3 -38.9 -9.85 -38.35 -9.85 -37.6 L -9.85 -34.9 Q -9.85 -34.15 -9.3 -33.55 -8.75 -33.05 -7.95 -33.05 L 7.2 -33.05 Q 7.95 -33.05 8.5 -33.55 9.05 -34.15 9.05 -34.9 L 9.05 -37.6 Q 9.05 -38.35 8.5 -38.9 M 5.3 -36.8 L 5.3 -35.7 -6.1 -35.7 -6.1 -36.8 5.3 -36.8 M 24.45 -27.6 Q 23.9 -28.15 23.15 -28.15 22.35 -28.15 21.8 -27.55 21.3 -27 21.3 -26.25 21.3 -25.7 21.6 -25.25 L 17.4 -21.1 Q 13 -24.8 7.7 -26.35 L 7.7 -30.1 Q 7.7 -30.85 7.2 -31.4 6.6 -31.95 5.85 -31.95 L -6.9 -31.95 Q -7.65 -31.95 -8.2 -31.4 -8.75 -30.85 -8.75 -30.1 L -8.75 -26.25 Q -13.7 -24.7 -17.85 -21.25 L -21.65 -25.05 Q -21.25 -25.6 -21.25 -26.25 -21.25 -27.05 -21.8 -27.55 -22.35 -28.15 -23.15 -28.15 -23.9 -28.15 -24.45 -27.55 L -25.65 -26.4 Q -25.7 -26.35 -25.7 -26.3 L -26.8 -25.3 Q -27.4 -24.8 -27.4 -24.05 -27.45 -23.25 -26.9 -22.7 -26.4 -22.1 -25.6 -22.05 -24.9 -22.05 -24.4 -22.45 L -20.6 -18.7 Q -28.1 -10.75 -28.1 0.3 -28.1 11.8 -19.95 19.9 -11.85 28.05 -0.35 28.05 11.15 28.05 19.3 19.9 27.4 11.8 27.4 0.3 27.4 -10.6 20.15 -18.5 L 24.25 -22.6 Q 24.8 -22.05 25.55 -22.05 26.35 -22.05 26.9 -22.65 27.4 -23.2 27.4 -23.95 27.4 -24.75 26.85 -25.3 L 24.45 -27.6 M 3.95 -28.2 L 3.95 -24.9 Q 3.95 -24.25 4.35 -23.7 4.75 -23.2 5.4 -23.05 11.75 -21.6 16.65 -16.7 23.65 -9.65 23.65 0.3 23.65 10.25 16.65 17.25 9.6 24.3 -0.35 24.3 -10.25 24.3 -17.3 17.25 -24.3 10.25 -24.3 0.3 -24.3 -9.65 -17.3 -16.7 -17 -17 -16.7 -17.25 L -16.65 -17.3 Q -16.65 -17.35 -16.6 -17.35 L -16.6 -17.4 Q -16.5 -17.45 -16.35 -17.55 -11.95 -21.6 -6.45 -23 -5.8 -23.15 -5.4 -23.65 -5 -24.15 -5 -24.8 L -5 -28.2 3.95 -28.2 M -1.65 21.1 Q -1.65 21.8 -1.15 22.3 -0.7 22.75 0 22.75 0.7 22.75 1.15 22.3 1.65 21.8 1.65 21.1 1.65 20.45 1.15 19.9 0.7 19.45 0 19.45 -0.7 19.45 -1.15 19.9 -1.65 20.45 -1.65 21.1 M -21.8 -1.2 Q -22.25 -0.7 -22.25 -0.05 -22.25 0.65 -21.8 1.15 -21.3 1.65 -20.6 1.65 -19.95 1.65 -19.4 1.15 -18.95 0.65 -18.95 -0.05 -18.95 -0.7 -19.4 -1.2 -19.95 -1.7 -20.6 -1.7 -21.3 -1.7 -21.8 -1.2 M 19.1 -1.2 Q 18.65 -0.7 18.65 -0.05 18.65 0.65 19.1 1.15 19.6 1.65 20.3 1.65 20.95 1.65 21.45 1.15 21.95 0.65 21.95 -0.05 21.95 -0.7 21.45 -1.2 20.95 -1.7 20.3 -1.7 19.6 -1.7 19.1 -1.2 M 1.65 -1.65 Q 0.95 -2.35 0 -2.35 -0.95 -2.35 -1.65 -1.65 -2.35 -1 -2.35 -0.05 -2.35 0.95 -1.65 1.65 -0.95 2.3 0 2.3 0.95 2.3 1.65 1.65 2.35 0.95 2.35 -0.05 2.35 -1 1.65 -1.65 M 0 -18.15 Q 0.7 -18.15 1.15 -18.6 1.65 -19.1 1.65 -19.8 1.65 -20.45 1.15 -20.95 0.7 -21.45 0 -21.45 -0.7 -21.45 -1.15 -20.95 -1.65 -20.45 -1.65 -19.8 -1.65 -19.1 -1.15 -18.6 -0.7 -18.15 0 -18.15 Z');

function renderBoardClock(centerX, centerY, remainingCentiseconds, accentColor){
  var clockScale = 0.8;
  var handProgress = Number.isFinite(remainingCentiseconds) ? ((remainingCentiseconds % 600) / 600) : 0;

  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.scale(clockScale, clockScale);

  ctx.globalAlpha = 0.18;
  ctx.fillStyle = accentColor;
  ctx.fill(boardClockFacePath);

  ctx.globalAlpha = 1;
  ctx.fillStyle = accentColor;
  ctx.fill(boardClockFacePath);

  ctx.rotate((-Math.PI / 2) + ((Math.PI * 2) * handProgress));
  ctx.fillRect(-2.1, -18, 4.2, 18);
  ctx.restore();

  var mainText = formatClockLabel(remainingCentiseconds);
  ctx.fillStyle = accentColor;
  ctx.font = "bold 14px Arial";
  ctx.fillText(mainText, centerX - (ctx.measureText(mainText).width / 2), centerY + 44);
}



function drawOpponentBoard(){
  if(!opponentState){
    ctx.font = "16px Arial";
    ctx.fillStyle = CANVAS_ACCENT;
    ctx.fillText("Waiting for opponent board...", opponentGridOffSetX + 40, 200);
    return;
  }

  var opGridSize = opponentState.gridSize || 3;
  var opOverallGridSize = opGridSize * cellSize;
  var opGridOffSetY = gridOffSetY;

  ctx.globalAlpha = 0.1;
  ctx.fillStyle = CANVAS_ACCENT;
  ctx.roundRect(opponentGridOffSetX-gridBoundaryMargin,opGridOffSetY-gridBoundaryMargin,opOverallGridSize+(gridBoundaryMargin+15),opOverallGridSize+(gridBoundaryMargin+15), 5,true,false);
  ctx.globalAlpha = 1;
  ctx.strokeStyle = CANVAS_ACCENT;
  ctx.lineWidth = .75;
  ctx.roundRect(opponentGridOffSetX-gridBoundaryMargin,opGridOffSetY-gridBoundaryMargin,opOverallGridSize+(gridBoundaryMargin+15),opOverallGridSize+(gridBoundaryMargin+15), 5,false,true);

  var X = opponentState.Xcounters || [];
  var Y = opponentState.Ycounters || [];
  for (var counts in X){
    for(var seg in X[counts]){
      ctx.font = "11px Arial";
      ctx.fillStyle = CANVAS_ACCENT;
      ctx.fillText(X[counts][X[counts].length-seg-1], opponentGridOffSetX+(cellSize/4)+(counts*cellSize), opGridOffSetY-10-(seg*15));
    }
  }
  for (var rowCounts in Y){
    for(var rowSeg in Y[rowCounts]){
      ctx.font = "11px Arial";
      ctx.fillStyle = CANVAS_ACCENT;
      ctx.fillText(Y[rowCounts][Y[rowCounts].length-rowSeg-1], opponentGridOffSetX-(rowSeg*15)-14, opGridOffSetY+6+(cellSize/4)+(rowCounts*cellSize));
    }
  }

  var guesses = opponentState.gridGuesses || [];
  var opGrid = opponentState.grid || [];
  for(var i = 0; i<opGridSize;i++){
    for(var j = 0; j<opGridSize;j++){
      ctx.lineWidth = 1;
      ctx.strokeStyle = CANVAS_ACCENT;
      ctx.fillStyle = CANVAS_CELL_BG;
      ctx.roundRect(i*cellSize+opponentGridOffSetX,j*cellSize+opGridOffSetY,cellSize,cellSize, 3,true,true);
      if(guesses[i] && guesses[i][j] === 1){
        if(opGrid[i] && opGrid[i][j] === 1){
          ctx.fillStyle = CANVAS_ACCENT;
          ctx.roundRect(i*cellSize+opponentGridOffSetX,j*cellSize+opGridOffSetY,cellSize,cellSize, 3,true,false);
        } else {
          renderCross(i*cellSize+opponentGridOffSetX-3,j*cellSize+opGridOffSetY-3);
        }
      }
    }
  }

  var opLives = opponentState.lives || 0;
  var opponentBoardCenterX = getOuterBoardCenterX(opponentGridOffSetX, opOverallGridSize);
  renderHeartsRow(opponentBoardCenterX, opGridOffSetY + opOverallGridSize + 25, opLives, renderOpponentHeart);

  var opScore = opponentState.score || 0;
  var opponentScoreX = opponentGridOffSetX - gridBoundaryMargin - 22;
  for(var star = 0; star < opScore; star++){
    renderStar(opponentScoreX,60+(star%5*20));
  }
}

function initMultiplayer(){
  if(!socket){
    updateMultiplayerPanel([]);
    updateLeaderboardPanel([]);
    return;
  }
  socket.on("players:update", function(players){
    updateMultiplayerPanel(players);
  });

  socket.on("leaderboard:update", function(entries){
    updateLeaderboardPanel(entries);
  });

  socket.on("match:ready", function(payload){
    pendingPredictions = [];
    gameMode = "waiting";
    setMatchStatus("Match found! Starting vs " + payload.opponentName + "...");
  });

  socket.on("match:update", function(payload){
    applyServerState(payload.player);
    opponentState = payload.opponent;
    myDisplayName = (payload.player && payload.player.name) ? payload.player.name : (myPlayerName || "You");
    opponentDisplayName = (payload.opponent && payload.opponent.name) ? payload.opponent.name : "Opponent";
    drawOpponentBoard();
    if(gameMode === "waiting" || gameMode === "menu"){
      gameMode = payload.player && payload.player.gameMode ? payload.player.gameMode : "play";
      if(gameMode === "countdown"){
        setMatchStatus("Match starts in 3...");
      } else {
        setMatchStatus("Playing against " + (payload.opponent && payload.opponent.name ? payload.opponent.name : "opponent"));
      }
      startButton.disabled = true;
      startButton.textContent = "In Match";
      setMatchmakingVisible(false);
    }
    if(payload.player && payload.player.gameMode === "gameOver"){
      gameMode = "gameOver";
      setShopVisible(false);
      if(payload.playerRematchRequested){
        startButton.disabled = true;
        startButton.textContent = "Waiting...";
        if(payload.opponentRematchRequested){
          setMatchStatus("Restarting match...");
        } else {
          setMatchStatus("Rematch requested. Waiting for opponent...");
        }
      } else {
        setMatchStatus("Game over. Click Start to request a rematch.");
        startButton.disabled = false;
        startButton.textContent = "Start";
      }
      setMatchmakingVisible(true);
    }
  });

  socket.on("match:ended", function(payload){
    gameMode = "menu";
    opponentState = null;
    opponentDisplayName = "Opponent";
    myDisplayName = myPlayerName || "You";
    drawOpponentBoard();
    startButton.disabled = false;
    startButton.textContent = "Start";
    setMatchmakingVisible(true);
    pendingPredictions = [];
    setShopVisible(false);
    setMatchStatus(payload.reason || "Match ended.");
  });
}

var grid = [];
var gridGuesses = [];

var can = document.getElementById("speedogram");

can.addEventListener("touchstart", mouseDown, false);
can.addEventListener("touchend", mouseUp, false);

can.addEventListener("mousemove", mouseMove, false);
can.addEventListener("mouseup", mouseUp, false);
can.addEventListener("mousedown", mouseDown, false);
can.addEventListener("click", click, false);

var ctx = can.getContext("2d");
var mouseX;
var mouseY;

function init(){
  gameMode = "menu";
  if(appVersionEl){
    appVersionEl.textContent = versionNumber;
  }
  myDisplayName = myPlayerName || "You";
  drawOpponentBoard();
  setMatchmakingVisible(true);
  enterFrame();
}

function renderBoardHeaders(){
  var layout = updateBoardLayout();
  var myBoardCenterX = getOuterBoardCenterX(gridOffSetX, overallGridSize);
  var opponentBoardCenterX = getOuterBoardCenterX(opponentGridOffSetX, (layout.opponentGridSize * cellSize));

  ctx.font = "20px Arial";
  ctx.fillStyle = CANVAS_ACCENT;

  var myName = myDisplayName || "You";
  var opponentName = opponentDisplayName || "Opponent";

  ctx.fillText(myName, myBoardCenterX - (ctx.measureText(myName).width / 2), 34);
  ctx.fillText(opponentName, opponentBoardCenterX - (ctx.measureText(opponentName).width / 2), 34);
}

function enterFrame(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  var layout = updateBoardLayout();
  renderBoardHeaders();

  var myRemainingTime = getRemainingCentiseconds(timer, timeLimit);
  var opponentRemainingTime = getRemainingCentiseconds(opponentState && opponentState.timer, opponentState && opponentState.timeLimit);

  var myClockColor = CANVAS_ACCENT;
  var opponentClockColor = CANVAS_ACCENT;
  if(Number.isFinite(myRemainingTime) && Number.isFinite(opponentRemainingTime)){
    if(myRemainingTime > opponentRemainingTime){
      myClockColor = "#62e78b";
      opponentClockColor = CANVAS_DANGER;
    } else if(opponentRemainingTime > myRemainingTime){
      myClockColor = CANVAS_DANGER;
      opponentClockColor = "#62e78b";
    }
  }

  var shouldRenderMatchClocks = gameMode == "play" || gameMode == "gameOver" || gameMode == "countdown" || gameMode == "shop" || gameMode == "roundOver";
  if(shouldRenderMatchClocks){
    var clockInset = 64;
    var myClockX = Math.min(canvas.width - clockInset, layout.myOuterLeft + layout.myOuterWidth + clockInset);
    var opponentClockX = Math.min(canvas.width - clockInset, layout.opponentOuterLeft + layout.opponentOuterWidth + clockInset);
    var boardClockY = boardTopY - 38;

    renderBoardClock(myClockX, boardClockY, myRemainingTime, myClockColor);
    renderBoardClock(opponentClockX, boardClockY, opponentRemainingTime, opponentClockColor);

    var timerCenterX = layout.timerCenterX;
    ctx.font = "bold 16px Arial";
    ctx.fillStyle = CANVAS_ACCENT;
    var roundLabel = "Round: " + currentRound + "/" + totalRounds;
    ctx.fillText(roundLabel, timerCenterX - (ctx.measureText(roundLabel).width / 2), 160);
  }

  if(gameMode == "play" || gameMode == "gameOver" || gameMode == "countdown" || gameMode == "shop" || gameMode == "roundOver"){
    renderBackdrop();
    renderCells();
    renderClueText();
    renderHealth();
    renderScore();
    drawOpponentBoard();
  }
  if(gameMode == "play"){
    renderMouseOver();
  }
  if(gameMode == "shop"){
    renderShopOverlay();
  }
  if(gameMode == "countdown"){
    renderCountdownOverlay();
  }
  if(gameMode == "gameOver"){
    renderGameOver();
  }
  window.requestAnimationFrame(enterFrame);
}

function renderShopOverlay(){
  var overlayCenterX = canvas.width / 2;
  var overlayCenterY = canvas.height / 2;
  var overlayWidth = Math.max(overallGridSize + 48, 360);
  var overlayHeight = 136;
  var overlayX = overlayCenterX - (overlayWidth / 2);
  var overlayY = overlayCenterY - (overlayHeight / 2);

  ctx.globalAlpha = 0.82;
  ctx.fillStyle = CANVAS_CELL_BG;
  ctx.roundRect(overlayX, overlayY, overlayWidth, overlayHeight, 8, true, false);
  ctx.globalAlpha = 1;

  ctx.fillStyle = CANVAS_TEXT;
  ctx.font = "bold 24px Arial";
  var title = "Round " + currentRound + " complete";
  ctx.fillText(title, overlayCenterX - (ctx.measureText(title).width / 2), overlayCenterY - 8);
  ctx.font = "16px Arial";
  var subtitle = hasPurchasedThisShop ? "Waiting for opponent to choose..." : "Choose an upgrade below";
  ctx.fillText(subtitle, overlayCenterX - (ctx.measureText(subtitle).width / 2), overlayCenterY + 24);
}
function renderCountdownOverlay(){
  var seconds = Math.max(1, countdownRemaining || 0);
  var boardCenterX = canvas.width / 2;
  var boardCenterY = canvas.height / 2;
  var overlayWidth = overallGridSize + 48;
  var overlayHeight = overallGridSize + 48;
  var overlayX = boardCenterX - (overlayWidth / 2);
  var overlayY = boardCenterY - (overlayHeight / 2);

  ctx.globalAlpha = 0.82;
  ctx.fillStyle = CANVAS_CELL_BG;
  ctx.roundRect(overlayX, overlayY, overlayWidth, overlayHeight, 8, true, false);
  ctx.globalAlpha = 1;

  ctx.fillStyle = CANVAS_TEXT;
  ctx.font = "bold 56px Arial";
  var countdownText = String(seconds);
  ctx.fillText(countdownText, boardCenterX - (ctx.measureText(countdownText).width / 2), boardCenterY + 20);

  ctx.font = "16px Arial";
  var message = "Get ready!";
  ctx.fillText(message, boardCenterX - (ctx.measureText(message).width / 2), boardCenterY - 30);
}

function renderGameOver(){
  var gameOverText = winnerText || ("Final Score: " + score);
  var overlayCenterX = canvas.width / 2;
  var overlayCenterY = canvas.height / 2;
  var overlayWidth = Math.min(560, canvas.width - 110);
  var overlayHeight = 150;
  var overlayX = overlayCenterX - (overlayWidth / 2);
  var overlayY = overlayCenterY - (overlayHeight / 2);

  ctx.globalAlpha = 0.9;
  ctx.fillStyle = CANVAS_CELL_BG;
  ctx.roundRect(overlayX, overlayY, overlayWidth, overlayHeight, 12, true, false);
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1.2;
  ctx.strokeStyle = CANVAS_ACCENT;
  ctx.roundRect(overlayX, overlayY, overlayWidth, overlayHeight, 12, false, true);

  ctx.fillStyle = CANVAS_TEXT;
  ctx.font = "bold 34px Arial";
  ctx.fillText(gameOverText, overlayCenterX - (ctx.measureText(gameOverText).width / 2), overlayCenterY - 8);

  var rematchHint = "Click Start to request a rematch";
  ctx.fillStyle = "#9fcfff";
  ctx.font = "16px Arial";
  ctx.fillText(rematchHint, overlayCenterX - (ctx.measureText(rematchHint).width / 2), overlayCenterY + 30);
}

function hitTest(object){
  //Search scene objects for name
  for(var objects in sceneObjects){
    if(sceneObjects[objects].name == object){
      var obj = sceneObjects[objects];
    }
  }
  if(mouseX > obj.x-obj.width/2 && mouseX < obj.x+obj.width/2 && mouseY > obj.y-obj.height/2 && mouseY < obj.y+obj.height/2){
    return true;
  } else {
    return false;
  }
}

function renderSceneObjects(){
  for(var object in sceneObjects){
    var obj = sceneObjects[object];
    if(obj.type == "Button"){
        renderButton(obj.x,obj.y,obj.width,obj.height,obj.text);
    }
  }
}
function clearSceneObjects(){
  sceneObjects = [];
}

function renderButton(x,y,width,height,text){
  ctx.translate(x,y);
  ctx.globalAlpha = 0.2;
  ctx.fillStyle = CANVAS_ACCENT;
  ctx.roundRect(-width/2,-height/2,width,height,3,true,false);
  ctx.globalAlpha = 1;
  ctx.strokeStyle = CANVAS_ACCENT;
  ctx.roundRect(-width/2,-height/2,width,height,3,false,true);
  ctx.font = "18px Arial";
  ctx.fillStyle = CANVAS_ACCENT;
  ctx.fillText(text,-(ctx.measureText(text).width/2),6);
  ctx.translate(-x,-y);
}

function createObject(xC,yC,widthC,heightC,nameC,typeC,textC){
  sceneObjects.push({x:xC,y:yC,width:widthC,height:heightC,name:nameC,type:typeC,text:textC});
}

function renderStopwatchTimer(x,y,time){
  var timeSeconds = timeLimit/100-Math.floor(time/100);
  ctx.save();
  ctx.translate(x,y);
  ctx.font = "12px Arial";
  ctx.fillStyle = CANVAS_ACCENT;
  ctx.fillText(timeSeconds,0,0);
  ctx.restore();
}

function renderStopwatchHand(x,y,time){
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate((Math.PI / 180) * time*360/timeLimit);
  ctx.fillStyle = CANVAS_ACCENT
  ctx.fillRect(-2,-19,4,19);
  ctx.restore();
}
function renderScore(){
  var myScoreX = gridOffSetX-gridBoundaryMargin-22;
  for(var i=0;i<score;i++){
    renderStar(myScoreX,60+(i%5*20));
  }
}
function renderStar(x,y){
  let p = new Path2D('M 0.55 -7.9 Q 0.5 -8.1 0.3 -8.25 0.15 -8.35 -0.1 -8.35 -0.3 -8.35 -0.5 -8.25 -0.65 -8.1 -0.75 -7.9 L -2.55 -2.7 -8.05 -2.55 Q -8.3 -2.55 -8.45 -2.45 -8.6 -2.3 -8.7 -2.1 -8.75 -1.9 -8.7 -1.65 -8.6 -1.45 -8.45 -1.35 L -4.1 2 -5.65 7.25 Q -5.75 7.45 -5.65 7.7 -5.6 7.9 -5.45 8.05 -5.25 8.15 -5 8.15 -4.8 8.15 -4.6 8.05 L -0.1 4.9 4.45 8.05 Q 4.6 8.15 4.8 8.15 5.05 8.15 5.25 8.05 5.4 7.9 5.45 7.7 5.55 7.45 5.45 7.25 L 3.9 2 8.25 -1.35 Q 8.4 -1.45 8.5 -1.65 8.55 -1.9 8.5 -2.1 8.4 -2.3 8.25 -2.45 8.1 -2.55 7.9 -2.55 L 2.35 -2.7 0.55 -7.9 Z');
  ctx.translate(x,y);
  ctx.fillStyle = CANVAS_ACCENT
  ctx.fill(p);
  ctx.translate(-x,-y);
}
function renderStopwatch(x,y){
  let p = new Path2D('M 8.5 -38.9 Q 7.95 -39.45 7.2 -39.45 L -7.95 -39.45 Q -8.75 -39.45 -9.3 -38.9 -9.85 -38.35 -9.85 -37.6 L -9.85 -34.9 Q -9.85 -34.15 -9.3 -33.55 -8.75 -33.05 -7.95 -33.05 L 7.2 -33.05 Q 7.95 -33.05 8.5 -33.55 9.05 -34.15 9.05 -34.9 L 9.05 -37.6 Q 9.05 -38.35 8.5 -38.9 M 5.3 -36.8 L 5.3 -35.7 -6.1 -35.7 -6.1 -36.8 5.3 -36.8 M 24.45 -27.6 Q 23.9 -28.15 23.15 -28.15 22.35 -28.15 21.8 -27.55 21.3 -27 21.3 -26.25 21.3 -25.7 21.6 -25.25 L 17.4 -21.1 Q 13 -24.8 7.7 -26.35 L 7.7 -30.1 Q 7.7 -30.85 7.2 -31.4 6.6 -31.95 5.85 -31.95 L -6.9 -31.95 Q -7.65 -31.95 -8.2 -31.4 -8.75 -30.85 -8.75 -30.1 L -8.75 -26.25 Q -13.7 -24.7 -17.85 -21.25 L -21.65 -25.05 Q -21.25 -25.6 -21.25 -26.25 -21.25 -27.05 -21.8 -27.55 -22.35 -28.15 -23.15 -28.15 -23.9 -28.15 -24.45 -27.55 L -25.65 -26.4 Q -25.7 -26.35 -25.7 -26.3 L -26.8 -25.3 Q -27.4 -24.8 -27.4 -24.05 -27.45 -23.25 -26.9 -22.7 -26.4 -22.1 -25.6 -22.05 -24.9 -22.05 -24.4 -22.45 L -20.6 -18.7 Q -28.1 -10.75 -28.1 0.3 -28.1 11.8 -19.95 19.9 -11.85 28.05 -0.35 28.05 11.15 28.05 19.3 19.9 27.4 11.8 27.4 0.3 27.4 -10.6 20.15 -18.5 L 24.25 -22.6 Q 24.8 -22.05 25.55 -22.05 26.35 -22.05 26.9 -22.65 27.4 -23.2 27.4 -23.95 27.4 -24.75 26.85 -25.3 L 24.45 -27.6 M 3.95 -28.2 L 3.95 -24.9 Q 3.95 -24.25 4.35 -23.7 4.75 -23.2 5.4 -23.05 11.75 -21.6 16.65 -16.7 23.65 -9.65 23.65 0.3 23.65 10.25 16.65 17.25 9.6 24.3 -0.35 24.3 -10.25 24.3 -17.3 17.25 -24.3 10.25 -24.3 0.3 -24.3 -9.65 -17.3 -16.7 -17 -17 -16.7 -17.25 L -16.65 -17.3 Q -16.65 -17.35 -16.6 -17.35 L -16.6 -17.4 Q -16.5 -17.45 -16.35 -17.55 -11.95 -21.6 -6.45 -23 -5.8 -23.15 -5.4 -23.65 -5 -24.15 -5 -24.8 L -5 -28.2 3.95 -28.2 M -1.65 21.1 Q -1.65 21.8 -1.15 22.3 -0.7 22.75 0 22.75 0.7 22.75 1.15 22.3 1.65 21.8 1.65 21.1 1.65 20.45 1.15 19.9 0.7 19.45 0 19.45 -0.7 19.45 -1.15 19.9 -1.65 20.45 -1.65 21.1 M -21.8 -1.2 Q -22.25 -0.7 -22.25 -0.05 -22.25 0.65 -21.8 1.15 -21.3 1.65 -20.6 1.65 -19.95 1.65 -19.4 1.15 -18.95 0.65 -18.95 -0.05 -18.95 -0.7 -19.4 -1.2 -19.95 -1.7 -20.6 -1.7 -21.3 -1.7 -21.8 -1.2 M 19.1 -1.2 Q 18.65 -0.7 18.65 -0.05 18.65 0.65 19.1 1.15 19.6 1.65 20.3 1.65 20.95 1.65 21.45 1.15 21.95 0.65 21.95 -0.05 21.95 -0.7 21.45 -1.2 20.95 -1.7 20.3 -1.7 19.6 -1.7 19.1 -1.2 M 1.65 -1.65 Q 0.95 -2.35 0 -2.35 -0.95 -2.35 -1.65 -1.65 -2.35 -1 -2.35 -0.05 -2.35 0.95 -1.65 1.65 -0.95 2.3 0 2.3 0.95 2.3 1.65 1.65 2.35 0.95 2.35 -0.05 2.35 -1 1.65 -1.65 M 0 -18.15 Q 0.7 -18.15 1.15 -18.6 1.65 -19.1 1.65 -19.8 1.65 -20.45 1.15 -20.95 0.7 -21.45 0 -21.45 -0.7 -21.45 -1.15 -20.95 -1.65 -20.45 -1.65 -19.8 -1.65 -19.1 -1.15 -18.6 -0.7 -18.15 0 -18.15 Z');
  ctx.translate(x,y);
  ctx.fillStyle = CANVAS_ACCENT
  ctx.fill(p);
  ctx.translate(-x,-y);
}

function renderCross(x,y){
  let p = new Path2D('M 16.4 10.5 L 14.5 8.65 12.6 10.55 10.7 8.65 8.8 10.5 10.7 12.45 8.8 14.35 10.7 16.25 12.6 14.3 14.5 16.25 16.4 14.35 14.5 12.45 16.4 10.5 Z');
  ctx.translate(x,y);
  ctx.fillStyle = CANVAS_ACCENT
  ctx.fill(p);
  ctx.translate(-x,-y);
}

function renderHeartsRow(centerX, y, count, drawHeart){
  if(count <= 0){
    return;
  }
  var heartsRowWidth = ((count-1) * HEART_SPACING) + HEART_ICON_WIDTH;
  var heartsStartX = centerX - (heartsRowWidth/2);
  for(var i = 0; i < count; i++){
    drawHeart(heartsStartX + (i*HEART_SPACING), y);
  }
}

function renderHealth(){
  var boardCenterX = getOuterBoardCenterX(gridOffSetX, overallGridSize);
  renderHeartsRow(boardCenterX, gridOffSetY + overallGridSize + 25, lives, renderHeart);
}

function renderHeart(x,y){
  let p = new Path2D('M 24.1 7.05 Q 24.1 4.65 22.4 2.95 21.4 1.95 20.1 1.55 19.25 1.25 18.3 1.25 15.9 1.25 14.2 2.95 12.55 4.6 12.5 7 12.45 4.6 10.8 2.95 9.15 1.3 6.85 1.25 6.8 1.25 6.7 1.25 4.3 1.25 2.6 2.95 0.9 4.65 0.9 7.05 0.9 9 2.15 10.65 L 12.5 23.8 22.3 11.75 Q 24.1 9.45 24.1 7.05 Z');
  ctx.translate(x,y);
  ctx.fillStyle = CANVAS_DANGER
  ctx.fill(p);
  ctx.translate(-x,-y);
}

function renderOpponentHeart(x,y){
  let p = new Path2D('M 24.1 7.05 Q 24.1 4.65 22.4 2.95 21.4 1.95 20.1 1.55 19.25 1.25 18.3 1.25 15.9 1.25 14.2 2.95 12.55 4.6 12.5 7 12.45 4.6 10.8 2.95 9.15 1.3 6.85 1.25 6.8 1.25 6.7 1.25 4.3 1.25 2.6 2.95 0.9 4.65 0.9 7.05 0.9 9 2.15 10.65 L 12.5 23.8 22.3 11.75 Q 24.1 9.45 24.1 7.05 Z');
  ctx.translate(x,y);
  ctx.fillStyle = CANVAS_DANGER;
  ctx.fill(p);
  ctx.translate(-x,-y);
}

can.oncontextmenu = function (e) {
    e.preventDefault();
};

function renderMouseOver(){
  for(var i = 0; i<gridSize;i++){
    for(var j = 0; j<gridSize;j++){
      //check if mouse is over cell
      if(mouseX > i*cellSize+gridOffSetX && mouseX < i*cellSize+cellSize+gridOffSetX && mouseY > j*cellSize+gridOffSetY && mouseY < j*cellSize+cellSize+gridOffSetY){
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = CANVAS_ACCENT;
        ctx.roundRect(i*cellSize+gridOffSetX,j*cellSize+gridOffSetY,cellSize,cellSize, 3,true,false);
      }
      ctx.globalAlpha = 1;
    }
  }
}

function renderBackdrop(){
  ctx.globalAlpha = 0.1;
  ctx.fillStyle = CANVAS_ACCENT;
  ctx.roundRect(gridOffSetX-gridBoundaryMargin,gridOffSetY-gridBoundaryMargin,overallGridSize+(gridBoundaryMargin+15),overallGridSize+(gridBoundaryMargin+15), 5,true,false);
  ctx.globalAlpha = 1;
  ctx.strokeStyle = CANVAS_ACCENT;
  ctx.lineWidth = .75;
  ctx.roundRect(gridOffSetX-gridBoundaryMargin,gridOffSetY-gridBoundaryMargin,overallGridSize+(gridBoundaryMargin+15),overallGridSize+(gridBoundaryMargin+15), 5,false,true);
}
function renderClueText(){
  for (var counts in Xcounters){
    for(var seg in Xcounters[counts]){
      ctx.font = "11px Arial";
      ctx.fillStyle = CANVAS_ACCENT;
      ctx.fillText(Xcounters[counts][Xcounters[counts].length-seg-1], gridOffSetX+(cellSize/4)+(counts*cellSize), gridOffSetY-10-(seg*15));
    }
  }
  for (var counts in Ycounters){
    for(var seg in Ycounters[counts]){
      ctx.font = "11px Arial";
      ctx.fillStyle = CANVAS_ACCENT;
      ctx.fillText(Ycounters[counts][Ycounters[counts].length-seg-1], gridOffSetX-(seg*15)-14, gridOffSetY+6+(cellSize/4)+(counts*cellSize));
    }
  }
}
sceneObjects = [];
function getPointerPosition(evt){
  var sourceEvent = evt;
  if(evt && evt.touches && evt.touches.length){
    sourceEvent = evt.touches[0];
  } else if(evt && evt.changedTouches && evt.changedTouches.length){
    sourceEvent = evt.changedTouches[0];
  }
  if(!sourceEvent){
    return;
  }
  var rect = can.getBoundingClientRect();
  var scaleX = canvas.width / rect.width;
  var scaleY = canvas.height / rect.height;
  mouseX = (sourceEvent.clientX - rect.left) * scaleX;
  mouseY = (sourceEvent.clientY - rect.top) * scaleY;
}

function mouseMove(evt){
    getPointerPosition(evt);
    if(mouseState === "down"){
      sendActionFromPointerDrag(mouseButton);
    }
}
function gameOverScreen(){
    if(lives == 0){
      gameMode = "gameOver";
    }
}

function prunePendingPredictions(){
  if(!pendingPredictions || !pendingPredictions.length){
    return;
  }
  var now = Date.now();
  pendingPredictions = pendingPredictions.filter(function(action){
    return now - action.createdAt < 2000;
  });
  if(pendingPredictions.length > MAX_PENDING_PREDICTIONS){
    pendingPredictions = pendingPredictions.slice(pendingPredictions.length - MAX_PENDING_PREDICTIONS);
  }
}

function reconcilePendingPredictions(){
  if(!pendingPredictions || !pendingPredictions.length){
    return;
  }

  prunePendingPredictions();

  var remaining = [];
  for(var i = 0; i < pendingPredictions.length; i++){
    var action = pendingPredictions[i];
    if(action.puzzleId !== currentPuzzleId){
      continue;
    }
    if(!gridGuesses || !gridGuesses[action.x]){
      continue;
    }

    if(gridGuesses[action.x][action.y] === 1){
      continue;
    }

    applyLocalPrediction(action.x, action.y, action.button);
    remaining.push(action);
  }

  pendingPredictions = remaining;
}

function applyLocalPrediction(x, y, button){
  if(!grid || !gridGuesses || !grid[x] || !gridGuesses[x]){
    return;
  }

  if(grid[x][y] === 1 && gridGuesses[x][y] !== 1){
    gridGuesses[x][y] = 1;
    if(button !== 0){
      lives -= 1;
    } else {
      var columnGuesses = 0;
      var rowGuesses = 0;
      for(var k = 0; k < gridSize; k++){
        if(grid[x][k] === 1 && gridGuesses[x][k] === 1){
          columnGuesses += 1;
        }
        if(grid[k][y] === 1 && gridGuesses[k][y] === 1){
          rowGuesses += 1;
        }
      }
      if(columnGuesses === columnsTotal[x]){
        for(var l = 0; l < gridSize; l++){
          gridGuesses[x][l] = 1;
        }
      }
      if(rowGuesses === rowsTotal[y]){
        for(var m = 0; m < gridSize; m++){
          gridGuesses[m][y] = 1;
        }
      }
    }
  }

  if(grid[x][y] === 0 && gridGuesses[x][y] !== 1){
    gridGuesses[x][y] = 1;
    if(button !== 2){
      lives -= 1;
    }
  }

  if(lives <= 0){
    lives = 0;
    gameMode = "gameOver";
  }
}

function sendActionFromPointerDrag(button){
  if(gameMode != "play"){
    return;
  }
  for(var i = 0; i<gridSize;i++){
    for(var j = 0; j<gridSize;j++){
      if(mouseX > i*cellSize+gridOffSetX && mouseX < i*cellSize+cellSize+gridOffSetX && mouseY > j*cellSize+gridOffSetY && mouseY < j*cellSize+cellSize+gridOffSetY){
        if(lastDraggedCell && lastDraggedCell.x === i && lastDraggedCell.y === j && lastDraggedCell.button === button){
          return;
        }
        lastDraggedCell = { x: i, y: j, button: button };
        pendingPredictions.push({ x: i, y: j, button: button, puzzleId: currentPuzzleId, createdAt: Date.now() });
        prunePendingPredictions();
        applyLocalPrediction(i, j, button);
        if(button === 0){
          playSound("cellFilled");
        }
        if(socket){
          socket.emit("game:action", { x: i, y: j, button: button });
        }
        return;
      }
    }
  }
}

function mouseDown(evt){
	getPointerPosition(evt);
	mouseState = "down";
	mouseButton = typeof evt.button === "number" ? evt.button : 0;
  lastDraggedCell = null;
  sendActionFromPointerDrag(mouseButton);
}
function mouseUp(evt){
	getPointerPosition(evt);
	mouseState = "up";
	mouseButton = evt && typeof evt.button === "number" ? evt.button : 0;
  lastDraggedCell = null;
}
var intervalID;
function requestMatch(){
  if(!socket){
    setMatchStatus("No server connection.");
    return;
  }
  pendingPredictions = [];
  gameMode = "waiting";
  setMatchStatus("Waiting for an opponent...");
  setShopVisible(false);
  startButton.disabled = true;
  startButton.textContent = "Waiting...";
  socket.emit("matchmaking:join");
}

function click(evt){
  getPointerPosition(evt);
  if(evt.detail === 0 && gameMode == "play"){
    sendActionFromPointerDrag(0);
  }
}

function applyServerState(state){
  if(!state){
    return;
  }
  var previousGameMode = gameMode;
  var previousCountdownRemaining = countdownRemaining;
  var previousPuzzleId = currentPuzzleId;
  var nextPuzzleId = Number.isFinite(state.puzzleId) ? state.puzzleId : 0;
  if(nextPuzzleId !== currentPuzzleId){
    pendingPredictions = [];
    lastDraggedCell = null;
  }
  currentPuzzleId = nextPuzzleId;

  gameMode = state.gameMode;
  countdownRemaining = Number.isFinite(state.countdownRemaining) ? state.countdownRemaining : 0;
  timer = state.timer;
  level = state.level;
  score = state.score;
  shopPoints = Number.isFinite(state.shopPoints) ? state.shopPoints : 0;
  lives = state.lives;
  currentRound = state.round || currentRound;
  winnerText = state.winnerText || "";
  timeLimit = state.timeLimit;
  gridSize = state.gridSize;
  grid = state.grid;
  gridGuesses = state.gridGuesses;
  Xcounters = state.Xcounters;
  Ycounters = state.Ycounters;
  columnsTotal = state.columnsTotal;
  rowsTotal = state.rowsTotal;

  shopOptions = state.shopOptions || [];
  hasPurchasedThisShop = !!state.hasPurchasedThisShop;
  updateShopChoicesIfNeeded();

  reconcilePendingPredictions();

  if(gameMode === "countdown") {
    if(previousGameMode !== "countdown"){
      playSound("countdownBoop");
    }
    if(Number.isFinite(previousCountdownRemaining) && countdownRemaining < previousCountdownRemaining){
      playSound("countdownBoop");
    }
    setMatchStatus("Match starts in " + Math.max(1, countdownRemaining) + "...");
    setShopVisible(false);
    lastShopRenderKey = "";
    lastPlaySecondsRemaining = null;
  } else if(gameMode === "play") {
    var remainingCentiseconds = getRemainingCentiseconds(timer, timeLimit);
    var secondsRemaining = Number.isFinite(remainingCentiseconds) ? Math.ceil(remainingCentiseconds / 10) : null;
    if(Number.isFinite(lastPlaySecondsRemaining) && Number.isFinite(secondsRemaining) && previousGameMode === "play" && secondsRemaining < lastPlaySecondsRemaining){
      for(var tickSecond = lastPlaySecondsRemaining - 1; tickSecond >= secondsRemaining; tickSecond--){
        if(tickSecond <= 5 && tickSecond >= 1){
          playSound("clockTick");
        }
      }
    }
    lastPlaySecondsRemaining = Number.isFinite(secondsRemaining) ? secondsRemaining : null;
    setMatchStatus("Round " + currentRound + "/" + totalRounds + ": Playing against " + (opponentDisplayName || "opponent"));
    setShopVisible(false);
    lastShopRenderKey = "";
  } else if(gameMode === "roundOver") {
    lastPlaySecondsRemaining = null;
    if(previousGameMode !== "roundOver"){
      playSound("roundOver");
    }
    setMatchStatus("Round " + currentRound + " complete. Waiting for opponent...");
    setShopVisible(false);
    lastShopRenderKey = "";
  } else if(gameMode === "shop") {
    lastPlaySecondsRemaining = null;
    if(hasPurchasedThisShop){
      setMatchStatus("Waiting for other player...");
      setShopVisible(false);
      lastShopRenderKey = "";
    } else {
      var affordableCount = shopOptions.filter(function(option){
        var optionCost = Number.isFinite(option.cost) ? option.cost : 0;
        return shopPoints >= optionCost;
      }).length;
      if(affordableCount === 0){
        setMatchStatus("Shop: not enough shop points, waiting for next round...");
      } else {
        setMatchStatus("Shop: choose 1 upgrade for next round.");
      }
      setShopVisible(true);
    }
    if(shopTitleEl){
      shopTitleEl.textContent = "Round " + currentRound + " Shop";
    }
    if(shopPointsEl){
      shopPointsEl.textContent = shopPoints + " shop point" + (shopPoints === 1 ? "" : "s") + " to spend";
    }
  } else if(gameMode === "gameOver") {
    lastPlaySecondsRemaining = null;
    if(previousGameMode !== "gameOver"){
      playSound("roundOver");
    }
    setMatchStatus(winnerText || "Game over. Click Start to request a rematch.");
    setShopVisible(false);
    lastShopRenderKey = "";
  }

  if(gameMode !== "play") {
    pendingPredictions = [];
  }

  if(previousPuzzleId && nextPuzzleId !== previousPuzzleId && previousGameMode === "play"){
    playSound("puzzleCompleted");
  }

  overallGridSize = gridSize*cellSize;
  updateBoardLayout();
}

CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius, fill, stroke) {
    var cornerRadius = { upperLeft: 0, upperRight: 0, lowerLeft: 0, lowerRight: 0 };
    if (typeof stroke == "undefined") {
        stroke = true;
    }

    if (typeof radius === "object") {
        for (var side in radius) {
            cornerRadius[side] = radius[side];
        }
    }
  	if (typeof radius === "number"){
  		for (var side in cornerRadius) {
              cornerRadius[side] = radius;
          }
  	}

    this.beginPath();
    this.moveTo(x + cornerRadius.upperLeft, y);
    this.lineTo(x + width - cornerRadius.upperRight, y);
    this.quadraticCurveTo(x + width, y, x + width, y + cornerRadius.upperRight);
    this.lineTo(x + width, y + height - cornerRadius.lowerRight);
    this.quadraticCurveTo(x + width, y + height, x + width - cornerRadius.lowerRight, y + height);
    this.lineTo(x + cornerRadius.lowerLeft, y + height);
    this.quadraticCurveTo(x, y + height, x, y + height - cornerRadius.lowerLeft);
    this.lineTo(x, y + cornerRadius.upperLeft);
    this.quadraticCurveTo(x, y, x + cornerRadius.upperLeft, y);
    this.closePath();
    if (stroke) {
        this.stroke();
    }
    if (fill) {
        this.fill();
    }
}
var Xcounters = [];
var Ycounters = [];
var columnsTotal = [];
var rowsTotal = [];

function initGrid(){
	//reset main values
	grid = [];
	gridGuesses = [];
	Xcounters = [];
	Ycounters = [];
	columnsTotal = [];
	rowsTotal = [];

  for(var i = 0; i<this.gridSize;i++){
    var gridX = [];
    var gridGuessesX = [];
    for(var j = 0; j<this.gridSize;j++){
      var randomNumber = Math.floor(Math.random()*3);
      if (randomNumber>1){randomNumber=1;}
      gridX.push(randomNumber);
      gridGuessesX.push(0);
    }
    grid.push(gridX);
    gridGuesses.push(gridGuessesX);
  }

  //builds clues and row column total arrays
  for(var i = 0; i<this.gridSize;i++){
    var column = [];
    var count = 0;
	var countTotal =0;
    for(var j = 0; j<this.gridSize;j++){
      if(grid[i][j] == 1){
        count ++;
		countTotal ++;
      } else {
        if(count > 0){
          column.push(count);
          count = 0;
        }
      }
    }
    if(count > 0){
      column.push(count);
    }
	columnsTotal.push(countTotal);
    Xcounters.push(column);
  }
  for(var i = 0; i<this.gridSize;i++){
    var row = [];
    var count = 0
	var countTotal = 0;
    for(var j = 0; j<this.gridSize;j++){
      if(grid[j][i] == 1){
        count ++;
		countTotal ++;
        if(j == this.gridSize-1){
          row.push(count);
        }
      } else {
        if(count != 0){
          row.push(count);
          count = 0;
        }
      }
    }
	rowsTotal.push(countTotal);
    Ycounters.push(row);
  }
}

function renderCells(){
  for(var i = 0; i<this.gridSize;i++){
    for(var j = 0; j<this.gridSize;j++){
      ctx.lineWidth = 1;
      ctx.strokeStyle = CANVAS_ACCENT;
      ctx.fillStyle = CANVAS_CELL_BG;
      ctx.roundRect(i*cellSize+gridOffSetX,j*cellSize+gridOffSetY,cellSize,cellSize, 3,true,true);
      if(gridGuesses[i][j] == 1 && grid[i][j] == 1){
        ctx.fillStyle = CANVAS_ACCENT;
        ctx.roundRect(i*cellSize+gridOffSetX,j*cellSize+gridOffSetY,cellSize,cellSize, 3,true,false);
      }
      if(gridGuesses[i][j] == 1 && grid[i][j] == 0){
        renderCross(i*cellSize+gridOffSetX-3,j*cellSize+gridOffSetY-3);
      }
    }
  }
}


startButton.addEventListener("click", function(){
  var requestedName = playerNameInput.value && playerNameInput.value.trim();
  if(requestedName){
    myPlayerName = requestedName.slice(0,24);
    myDisplayName = myPlayerName || "You";
  }
  sendPlayerUpdate();
  if(gameMode === "gameOver" && socket){
    socket.emit("game:restart");
    startButton.disabled = true;
    startButton.textContent = "Waiting...";
    setMatchStatus("Rematch requested. Waiting for opponent...");
    return;
  }
  requestMatch();
});

if(soundToggleButton){
  soundToggleButton.addEventListener("click", function(){
    soundEnabled = !soundEnabled;
    persistSoundPreference();
    syncSoundButton();
  });
}

playerNameInput.addEventListener("change", function(){
  var requestedName = playerNameInput.value && playerNameInput.value.trim();
  if(requestedName){
    myPlayerName = requestedName.slice(0,24);
    myDisplayName = myPlayerName || "You";
    sendPlayerUpdate();
  }
});

if(helpLink){
  helpLink.addEventListener("click", function(evt){
    evt.preventDefault();
    setHelpModalVisible(true);
  });
}

if(closeHelpButton){
  closeHelpButton.addEventListener("click", function(){
    setHelpModalVisible(false);
  });
}

if(helpModal){
  helpModal.addEventListener("click", function(evt){
    if(evt.target === helpModal){
      setHelpModalVisible(false);
    }
  });
}

document.addEventListener("keydown", function(evt){
  if(evt.key === "Escape"){
    setHelpModalVisible(false);
  }
});

init();
initMultiplayer();
loadSoundPreference();
syncSoundButton();

</script>

</html>
